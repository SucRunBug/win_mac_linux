# Mini HTTP 博客篇

*基于Linux的系统接口以及C++构建的小型HTTP协议，可满足基本数据请求和发送，具有较强的扩展性*

*[Gitee链接](https://gitee.com/Yan_feiyu/mini-http)*

## 一、开发背景

### 1.1 为什么要实现http？

无论是PC端还是移动端，http都被广泛使用，是非常重要的协议。目前大多数的http教程都是关于其理论展开，要是通过真正的自主设计，会更加地了解好http的原理。

### 1.2 开发环境

语言：C/C++

操作系统：Ubuntu/CentOS 7 

代码编辑器：vim/Visual Studio Code

编译和调试工具：GCC/GDB

数据库：MySQL 

### 1.3 背景知识

#### 1.3.1 WWW

WWW（World Wide Web），中文称为万维网，简称Web，是一种基于互联网的信息传递和共享方式，可以使文本、图片、音频、视频等多种形式的数据在网络中互相链接，形成一个庞大的全球信息交流系统。

WWW的核心是**超文本标记语言**（HTML）和**超文本传输协议**（HTTP）。HTML是一种用于描述文档内容和结构的标记语言，它定义了文本、图像、链接等元素，并且通过标记语言来描述它们之间的关系。HTTP是一种基于请求-响应模式的应用层协议，用于在Web浏览器和Web服务器之间传输超文本数据。

WWW的使用方式通常是通过Web浏览器进行访问，用户可以通过输入URL（统一资源定位符）来访问网站或者点击链接进行页面之间的跳转。

*如果用户的URL没有指明要访问的某种资源(路径)，例如baidu.com，浏览器默认会加/，即为该域名下根目录baidu.com/，但是依旧没有告知服务器要访问什么资源，需要默认返回对应服务器的首页，一般为/index.html*

#### 1.3.2 HTTP 1.0 VS HTTP 1.1

1. **缓存处理方式不同**：HTTP 1.0 中的缓存机制非常简单，只有两个指令——"If-Modified-Since"和 "Expires"，而HTTP 1.1 引入了更多的缓存控制指令，例如"Cache-Control"、"ETag"、"If-Unmodified-Since"等，提高了缓存的灵活性和控制粒度。
2. **长连接和请求管道**：HTTP 1.0 中每个请求都需要建立一个新的连接，因此效率比较低下。而 HTTP 1.1 支持长连接（persistent connection），即在同一连接上可以发送多个请求和响应，减少了连接建立和关闭的开销。此外，HTTP 1.1 还支持请求管道（request pipelining），即在同一连接上可以同时发送多个请求，而无需等待前一个请求的响应。
3. **Host 头部**：HTTP 1.1 强制要求所有的请求都要包含 Host 头部，以区分不同的虚拟主机。
4. **错误处理**：HTTP 1.1 在处理错误时引入了更多的状态码，例如409（Conflict）和410（Gone），以更好地表示错误类型。
5. **传输编码**：HTTP 1.1 中引入了传输编码（transfer encoding）机制，可以在传输过程中对消息体进行编码，以提高传输效率。常用的编码方式包括 chunked 编码和 gzip 编码。

*本次项目主要是实现HTTP 1.0最基础的功能，笔者争取以后实现一下1.1版本*

下面介绍HTTP 1.0的基本内容：

HTTP 1.0 是最早的 HTTP 协议版本之一，其基本内容包括：

1. 请求方法（Request Methods）：HTTP 1.0 定义了三种请求方法，即 GET、POST 和 HEAD。其中 GET 用于获取资源，POST 用于提交数据，HEAD 用于仅获取响应头信息。
2. 响应状态码（Response Status Codes）：HTTP 1.0 定义了几十种响应状态码，用于表示请求的处理结果。例如，200 表示请求成功，404 表示请求的资源不存在，500 表示服务器内部错误等。
3. 消息头（Message Headers）：HTTP 1.0 定义了很多消息头，用于传递请求和响应的元数据信息。例如，User-Agent 用于表示请求方的浏览器或客户端类型，Content-Type 用于表示请求或响应消息体的类型，Content-Length 用于表示消息体的长度等。
4. 消息体（Message Body）：HTTP 1.0 允许在请求或响应中包含消息体，用于传递请求或响应的具体内容。例如，在 GET 请求中，消息体为空，而在 POST 请求中，消息体通常包含需要提交的数据。
5. 连接管理（Connection Management）：HTTP 1.0 每次请求都需要建立一个新的 TCP 连接，处理完毕后即关闭连接。这种方式会导致很多连接的建立和关闭开销，因此效率比较低下。

#### 1.3.3 套接字

套接字（Socket）是计算机网络中的一个抽象概念，它可以被视为是两台计算机之间的网络通信端点。套接字提供了一种标准的接口，使得应用程序可以通过网络进行通信，而不必关心底层网络细节。

套接字通常使用 **IP 地址和端口号**来标识网络通信的两端。**IP 地址用于标识网络中的主机，端口号则用于标识主机中运行的进程**。套接字可以通过不同的传输协议进行通信，例如 TCP 和 UDP 协议等。

在计算机网络中，套接字被广泛应用于各种网络应用程序，如 Web 浏览器、电子邮件客户端、文件传输客户端等。应用程序可以使用套接字来建立网络连接，发送和接收数据，以及关闭连接等操作。

## 二、整体框架

### 2.1 如何用c++模拟实现http协议

#### 2.1.1 了解HTTP协议的基本原理和工作方式

HTTP协议是一个客户端和服务器之间的通信协议，通过TCP / IP连接进行通信。它使用请求和响应的格式来传输数据。**HTTP请求由请求行、请求头和请求体组成**，而**HTTP响应由状态行、响应头和响应体组成**。所以可以使用C ++编写服务器端代码来解析请求，并根据请求返回相应的响应。

#### 2.1.2 实现一个简单的HTTP服务器的基本步骤

1. 创建一个TCP套接字，并将其绑定到服务器的IP地址和端口号上。
2. 监听来自客户端的连接请求。
3. 接受连接请求并接收HTTP请求。
4. 解析HTTP请求。
5. 根据请求生成响应并将其发送回客户端。
6. 关闭连接。

您可以使用C ++网络库来实现这些步骤，例如Boost.Asio或Poco C ++库。

我在此处穿插一些关于C++网络库的发展历史：

*C++网络库的发展历史可以追溯到上个世纪90年代，当时网络应用程序的需求开始迅速增长，人们开始开发各种网络库来简化网络编程。以下是一些常见的C++网络库及其发展历史：*

*ACE：ACE（Adaptive Communication Environment）是一种面向对象的网络编程框架，最初由Doug Schmidt等人于1995年开发。ACE提供了一组通用的C ++类，可以用于实现各种网络协议和应用程序。它已经被广泛应用于各种领域，包括通信、金融、医疗和国防等。*

*Boost.Asio：Boost.Asio是一个跨平台的C ++网络库，最初是由Christopher Kohlhoff于2003年开发的，现在已经成为Boost库的一部分。Boost.Asio提供了一组通用的异步I/O类，可以用于实现各种网络协议和应用程序。它已经被广泛应用于各种领域，包括游戏、社交、金融和数据中心等。*

*Poco C++库：Poco C++库是一个轻量级的跨平台的C ++网络库，最初由Günter Obiltschnig等人于2004年开发。Poco C++库提供了一组通用的C ++类，可以用于实现各种网络协议和应用程序。它已经被广泛应用于各种领域，包括嵌入式系统、移动设备和云计算等。*

*libcurl：libcurl是一个跨平台的C ++网络库，最初由Daniel Stenberg于1997年开发。libcurl提供了一组通用的C ++类，可以用于实现各种网络协议和应用程序。它已经被广泛应用于各种领域，包括网络爬虫、FTP客户端和Web服务等。*

*常见的使用示例包括：*

1. *实现HTTP服务器：使用C++网络库可以方便地实现HTTP服务器，可以处理HTTP请求和响应信息，提供静态内容和动态内容等功能。*
2. *实现Web爬虫：使用C++网络库可以方便地实现Web爬虫，可以爬取Web页面并提取信息。*
3. *实现TCP/IP客户端：使用C++网络库可以方便地实现TCP/IP客户端，可以与其他网络设备进行通信，例如数据库服务器、消息队列等。*
4. *实现WebSocket客户端：使用C++网络库可以方便地实现WebSocket客户端，可以提供实时通信功能，例如在线游戏、聊天室等。*
5. *实现RPC客户端/服务器：使用C++网络库可以方便地实现远程过程调用（RPC）客户端/服务器，可以实现不同机器之间的函数调用和消息传递。*
6. *实现UDP通信：使用C++网络库可以方便地实现UDP通信，可以实现点对点的高速数据传输，例如视频流传输、音频流传输等。*
7. *实现FTP客户端：使用C++网络库可以方便地实现FTP客户端，可以实现文件上传和下载等功能。*
8. *实现SMTP客户端：使用C++网络库可以方便地实现SMTP客户端，可以实现发送邮件等功能。*
9. *实现DNS客户端：使用C++网络库可以方便地实现DNS客户端，可以实现域名解析等功能。*
10. *实现网络安全应用程序：使用C++网络库可以方便地实现网络安全应用程序，例如防火墙、入侵检测等。*



除此之外，您可以使用Linux系统调用来处理HTTP请求和响应信息，而不必使用C ++网络库。事实上，大多数C ++网络库本质上也是使用底层系统调用来实现的。使用系统调用可以提供更高的灵活性和可控性，但需要更多的代码来实现相同的功能。以下是使用Linux系统调用实现HTTP服务器的基本步骤：

1. 创建一个TCP套接字，使用**bind函数**将其绑定到服务器的IP地址和端口号上，使用**listen函数**开始监听连接请求。
2. 使用**accept函数**接受客户端连接请求，并使用**recv函数**接收HTTP请求信息。
3. 解析HTTP请求信息，提取请求行、请求头和请求体等信息。
4. 根据请求信息生成相应的响应，包括状态行、响应头和响应体。
5. 使用**send函数**将响应信息发送回客户端，并关闭连接。

需要注意的是，使用系统调用来实现HTTP服务器需要处理一些底层细节，例如套接字的创建和关闭、文件描述符的管理、错误处理等。同时，由于HTTP协议的复杂性，需要花费一定的时间来处理HTTP请求和响应信息。

## 三、细节部分

### 3.1 HTTP请求和响应信息

#### 3.1.1 组成部分及其作用

**HTTP请求的基本结构：**

```
请求方法 URL HTTP协议版本
请求头部信息
空行
请求体
```

请求方法：指明对资源的操作类型，常见的有 GET、POST、PUT、DELETE 等。

URL：请求的资源的地址。

HTTP协议版本：指明请求使用的 HTTP 协议版本，如 HTTP/1.1。

请求头部信息：包含了一些请求的元信息，例如请求中使用的编码方式、缓存设置等。

空行：用于隔离请求头部信息和请求体。

请求体：请求发送的数据内容，如POST请求中的表单数据等。

**HTTP响应的基本结构：**

```
HTTP协议版本 状态码 状态描述
响应头部信息
空行
响应体
```

HTTP协议版本：指明响应使用的 HTTP 协议版本，如 HTTP/1.1。

状态码：指明服务器处理请求的结果，例如200表示请求成功，404表示请求的资源未找到。

状态描述：对状态码的简要描述。

响应头部信息：包含了一些响应的元信息，例如响应中使用的编码方式、缓存设置等。

空行：用于隔离响应头部信息和响应体。

响应体：响应的实际内容，可以是HTML页面、图片、音频等。



#### 3.1.2 解析和处理方式

在解析HTTP请求和响应时，可以使用一些工具或库来处理，例如Python中的`requests`库或Node.js中的`http`模块。这些工具和库提供了API来访问请求和响应中的各个部分，例如请求方法、URL、请求头部信息等，从而方便地获取和解析有效信息。

如果仅仅使用Linux的系统调用：

1. 创建套接字并绑定端口：使用`socket`和`bind`系统调用创建套接字并绑定端口，以便客户端可以连接到服务器。
2. 监听套接字：使用`listen`系统调用开始监听套接字，以便接受客户端的连接请求。
3. 接受连接：使用`accept`系统调用接受客户端的连接请求，并返回一个新的套接字，用于与该客户端进行通信。*（这个新套接字不需要再次绑定，该套接字已经自动绑定了客户端的地址和端口号，可以直接使用该套接字与客户端进行通信。）*
4. 读取HTTP请求报文：使用`read`系统调用读取从客户端发送过来的HTTP请求报文。一般来说，可以使用循环读取的方式，将HTTP请求报文读取到一个缓冲区中。
5. 解析HTTP请求报文：在读取完HTTP请求报文之后，需要对其进行解析，以提取出HTTP请求的方法、URI、协议版本、请求头、请求体等信息。可以使用字符串操作、正则表达式等方法进行解析。
6. 处理HTTP请求：根据HTTP请求的方法、URI、请求头、请求体等信息，执行相应的处理逻辑，并生成HTTP响应报文。
7. 发送HTTP响应报文：使用`send`系统调用将HTTP响应报文发送给客户端。
8. 关闭连接：使用`close`系统调用关闭套接字，释放资源。

### 3.2 HTTP常用的请求方法

1. GET：用于**获取资源**。发送GET请求时，服务器会返回请求的资源，通常是HTML文件、图片、音频等。
2. POST：用于**提交数据**。发送POST请求时，请求的数据会包含在请求体中，通常用于提交表单、上传文件等操作。
3. PUT：用于**更新资源**。发送PUT请求时，请求的数据会包含在请求体中，通常用于更新已有的资源。
4. DELETE：用于**删除资源**。发送DELETE请求时，服务器会删除请求指定的资源。
5. HEAD：用于**获取资源的头部信息**。发送HEAD请求时，服务器只会返回请求的资源的头部信息，不会返回资源的内容。*在HTTP请求中，每个请求头都包含了一些元数据，例如请求的方法、请求的URI、请求的协议版本、请求的参数等等。而响应头同样也包含了一些元数据，例如响应的状态码、响应的协议版本、响应的内容类型等等。举个栗子，假设我们要下载一张图片。如果我们发送一个GET请求获取这个图片，那么服务器会将整个图片发送给我们，而我们只需要图片的元数据，例如图片的大小、类型、创建时间等等。如果我们发送一个HEAD请求，服务器只会返回图片的头部信息，我们就可以获取到图片的元数据而不需要获取整个图片。因此，HEAD请求方法是一个很有用的HTTP请求方法，它可以节省网络带宽和时间，并且可以让客户端更快地获取资源的元数据。*
6. OPTIONS：用于**获取服务器支持的请求方法**。发送OPTIONS请求时，服务器会返回支持的请求方法列表。
7. CONNECT：**用于建立TCP隧道**。发送CONNECT请求时，客户端会与服务器建立一个TCP隧道，通常用于**HTTPS加密通信**。
8. TRACE：用于**追踪请求-响应的传输路径**。发送TRACE请求时，服务器会返回请求的原始HTTP头部信息，以便客户端查看传输路径。

### 3.3 日志

#### 3.3.1 日志的格式

调试代码时，日志是一个非常有用的工具。以下是一些常见的日志格式，可用于帮助调试代码：

1. 时间戳：记录日志消息的时间。`time(nullpter)`只能获取到时间戳。
2. 日志级别：指示日志消息的严重程度。常见的日志级别包括 DEBUG（调试）、INFO（信息）、WARNING（警告）和ERROR（错误）。
3. 模块/类名：指示日志消息来自哪个模块或类。`__PRETTY_FUNCTION__`
4. 函数名：指示日志消息来自哪个函数。`__FUNCTION__`
5. 文件名和行号：指示日志消息所在的文件和行号。这对于定位代码中的错误非常有用。`__FILE__`, `__LINE__`
6. 日志消息内容：包含实际的日志消息。通常包括一些有用的上下文信息，如变量值、函数参数等。

例如，一个标准的日志消息格式可以如下所示：

```
[2023-03-02 12:34:56.789] [DEBUG] [module_name] [function_name] [filename:line_number] Message content with relevant context information.
```

其中，方括号中的各个字段分别表示时间戳、日志级别、模块/类名、函数名、文件名和行号以及实际的日志消息内容。

#### 3.3.2 时间戳转时间

```cpp
#include <iostream>
#include <ctime>
int main()
{
    time_t now = time(nullptr);
    tm *ltm = localtime(&now);
    std::cout << 1900 + ltm->tm_year << "/";
    std::cout << 1 + ltm->tm_mon << "/";
    std::cout << ltm->tm_mday << " ";
    std::cout << ltm->tm_hour << ":"; 
    std::cout << ltm->tm_min << ":"; 
    std::cout << ltm->tm_sec << std::endl; 
    return 0;
}
```

`localtime()`可以将时间戳转换为本地时间，返回一个`tm`结构体，包含了年月日时分秒等信息。

注意，`tm`结构体中的年份需要加上1900，月份需要加上1

### 3.4 CGI

在Web服务器上，**CGI（通用网关接口，Common Gateway Interface）是一种用于在Web服务器和其他软件之间传输数据的标准。它允许Web服务器在请求的URL页面中调用外部程序，并将输出返回到客户端浏览器。**

CGI 机制工作原理如下：

1. 客户端发送一个HTTP请求到Web服务器，请求访问一个特定的URL。
2. 服务器检查URL的扩展名，如果是指定的可执行文件类型（如.cgi或.pl），则会将请求传递给CGI程序。
3. CGI程序执行请求的操作，如生成动态内容或处理表单数据。
4. CGI程序将处理结果输出到标准输出流（STDOUT）。
5. Web服务器将标准输出流的内容返回给客户端浏览器，作为HTTP响应的一部分。

CGI程序可以使用各种编程语言编写，如Perl、Python、PHP、C/C++等。一旦Web服务器启用了CGI支持，它就可以在请求的URL页面中调用任何可执行文件，从而实现动态内容的生成和处理。但是，由于每次请求都需要启动新的进程，因此CGI机制的性能可能会受到影响。因此，现代的Web服务器通常使用更高效的替代方案，如FastCGI、ASP.NET等。




客户端请求服务端上的某个可执行文件，客户端可能还会传递一些参数，该可执行文件便可以称为cgi程序，可以是任何后端语言写的。

服务端的httpserver启动后是一个进程，cgi程序启动后也是一个进程，一个进程执行另一个进程需要用到**程序替换的技术**，即exec*系列接口。

父进程和子进程之间交换数据时，需要使用**进程间通信**的技术。

因为两进程之间有亲缘关系，所以首选匿名管道通信。要保证双向通信，所以使用两根管道。

子进程执行程序替换后要通过管道与父进程通信，但子进程并不会知道两根管道所对应的文件描述符，需要通过重定向技术将子进程0和1的文件描述符指向的位置换成与父进程通信的管道。

### 3.5 智能指针之shared_ptr

#### 3.5.1 基本概念

`std::shared_ptr` 是 C++ 标准库中的一个智能指针，用于管理动态分配的内存资源。与传统指针不同的是，`shared_ptr` 会自动地计数资源的引用次数，以确保资源在不再被引用时能够被正确释放，从而避免内存泄漏和悬空指针等问题。

`shared_ptr` 可以管理任意类型的动态分配内存资源，包括普通的数据类型、结构体、类对象、数组等。当一个 `shared_ptr` 被创建时，它会指向动态分配的内存资源，并将资源的引用次数初始化为 1。当有其他 `shared_ptr` 指向同一个资源时，它们会共享同一个引用计数，每当一个 `shared_ptr` 被创建或复制时，引用计数会加一。当一个 `shared_ptr` 被销毁或重置时，引用计数会减一。当引用计数变为 0 时，`shared_ptr` 会自动地调用资源的析构函数和释放函数，从而释放资源占用的内存空间。

#### 3.5.2 调试过程

*通过gdb调试到智能指针对象通过`->`调用其类中的成员函数时，并不能直接跳到该成员函数，而是经过一系列智能指针类中的函数调用。*

当我们使用`std::shared_ptr`时，编译器会将其展开为`std::__shared_ptr`类，它实现了引用计数和线程安全等功能。在调用`shared_ptr`的成员函数时，实际上是通过一系列函数调用间接访问了对象的成员函数。下面具体解释这些内部代码的功能和含义：

1. `std::__shared_ptr_access<HttpServer, (__gnu_cxx::_Lock_policy)2, false, false>::operator->`函数：这个函数重载了箭头运算符，用于获取智能指针内部的指针，并调用其成员函数。例如，在`http_server->InitServer()`中，箭头运算符会被重载，从而获取`HttpServer`类的指针，并调用其成员函数`InitServer()`。
2. `std::__shared_ptr_access<HttpServer, (__gnu_cxx::_Lock_policy)2, false, false>::_M_get`函数：这个函数用于获取指向`HttpServer`对象的指针。在`std::__shared_ptr_access<HttpServer, (__gnu_cxx::_Lock_policy)2, false, false>::operator->`函数内部，会调用这个函数获取指针，并进行后续操作。
3. `std::__shared_ptr<HttpServer, (__gnu_cxx::_Lock_policy)2>::get`函数：这个函数用于获取指向`HttpServer`对象的指针，与`_M_get`函数的作用相同。不同之处在于，这个函数是`std::__shared_ptr`类的成员函数，而`_M_get`函数是`std::__shared_ptr_access`类的成员函数。

这些函数的实现细节包括了线程安全的引用计数、内存分配和释放、指针管理等内容。在程序运行过程中，这些功能都是隐式实现的，我们可以通过使用`shared_ptr`的高级接口，方便地管理内存资源，避免常见的内存泄漏和悬垂指针问题。

### 3.6 listen的参数含义

在 Linux 系统中，`listen` 函数用于将一个套接字标记为**从客户端接受连接请求**的套接字，并**指定该套接字允许排队的最大连接数**。

`listen` 函数的第**一个参数是要标记为被动套接字的套接字描述符**，**第二个参数指定了该套接字所允许的最大连接数**。第二个参数的值表示操作系统内核中允许同时排队等待处理的连接数，超过这个数量的连接请求将被拒绝。

在设置第二个参数时，需要根据应用程序的实际需求和系统的负载情况来进行选择。**如果系统的负载较轻，可以将该参数设置为较大的值，以便充分利用系统资源**。但**如果系统负载较重，可能需要将该参数设置为较小的值，以避免过多的连接请求导致系统负载过高，影响系统的性能**。

在 Linux 系统中，当一个套接字被标记为可被动接受连接时，所有向该套接字发起连接请求的客户端都将被放入一个等待队列中，等待服务器端接受连接并处理请求。

对于这个等待队列，连接请求的处理顺序取决于客户端发起连接请求的时间。先发起连接请求的客户端会被优先处理，后发起连接请求的客户端会被放在等待队列的尾部，等待前面的连接请求被处理完毕后再进行处理。

如果等待时间过长，可能会采取一些措施来缓解等待队列过长的问题。例如，可以调整 `listen` 函数的第二个参数，增加等待队列的长度，以便允许更多的连接请求同时排队等待处理。同时，还可以采取一些负载均衡策略，例如将连接请求转发到其他服务器上处理，以缓解服务器负载压力。此外，还可以考虑使用异步 I/O 或多线程技术等方式提高服务器的并发处理能力，以减少连接请求的等待时间。

### 3.7 单例模式

单例模式（Singleton Pattern）是一种常用的设计模式，它可以保证一个类在运行时只能创建一个实例，并提供全局访问点供其他程序访问该实例。

在单例模式中，**一个类通常会包含一个私有的静态成员变量，用于存储该类的唯一实例**。同时，该类还需要定义一个**私有的构造函数**，以避免其他程序在运行时创建新的实例。为了提供全局访问点，单例模式还需要定义一个**静态的公共方法，用于返回该类的唯一实例**。

单例模式通常用于需要全局共享一个资源的情况，例如数据库连接池、线程池等。通过使用单例模式，可以避免重复创建实例和资源的浪费，同时还可以确保程序的正确性和安全性。

需要注意的是，单例模式虽然可以提供全局访问点，但同时也会导致程序的耦合性较高，不易于进行单元测试和模块化开发。因此，在使用单例模式时，需要权衡利弊，避免过度使用该模式导致程序的复杂度和难度增加。

### 3.8 HTTP是如何知道请求的资源类型

HTTP可以通过请求报文中的Accept字段和Content-Type字段来确定请求的资源类型。

Accept字段用于告诉服务器客户端可以接受的响应类型。客户端可以在请求头部中添加Accept字段，指定它所期望的响应内容类型。例如，Accept: text/html 表示客户端希望收到HTML文档作为响应。服务器可以根据Accept字段来选择最适合客户端的响应类型并返回。

Content-Type字段用于告诉服务器发送的请求体（例如POST请求中的表单数据）的类型。客户端可以在请求头部中添加Content-Type字段，指定请求体所使用的媒体类型。例如，Content-Type: application/json 表示请求体使用JSON格式。服务器可以根据Content-Type字段来解析请求体。

本项目中则使用了将文件扩展名转换为Content-Type的字段。

### 3.9 信号

#### 3.9.1 SIGPIPE

SIGPIPE是Linux操作系统中的一种信号，它表示管道破裂（Broken Pipe），通常在以下情况下会触发该信号：

1. 写入一个已关闭的管道。

2. 向一个没有读端口的管道中写入数据。

3. 向一个已经关闭了所有写端口的管道中写入数据。

在这些情况下，操作系统会向进程发送SIGPIPE信号，以提示进程管道已经破裂，不能再进行读写操作。

通常情况下，进程可以通过忽略或处理SIGPIPE信号来避免程序异常终止。如果进程不处理SIGPIPE信号，那么当进程写入破裂的管道时，操作系统会默认终止该进程。在编写网络编程或服务器程序时，如果不处理SIGPIPE信号，可能会导致服务器程序异常退出，从而影响系统的稳定性。

可以通过以下方式来处理SIGPIPE信号：

1. 忽略SIGPIPE信号：使用signal函数将SIGPIPE信号的处理方式设置为SIG_IGN，表示忽略该信号。

2. 自定义SIGPIPE信号处理函数：使用signal函数或sigaction函数将SIGPIPE信号的处理方式设置为自定义的信号处理函数，来处理该信号。

3. 在写入管道前判断管道的状态：可以使用fcntl函数获取管道的状态，判断管道是否已经破裂，从而避免写入破裂的管道。

需要注意的是，处理SIGPIPE信号时需要注意多线程和信号安全问题，以保证程序的正确性和可靠性。 

## 四、扩展思路

要扩展服务器的应用范围，您可以实现更多的HTTP协议特性和功能，例如：

1. 支持不同的HTTP请求方法，如GET、POST、PUT等。
2. 支持动态内容，例如使用CGI或FastCGI等技术。
3. 支持SSL / TLS协议，以提供安全连接。
4. 支持多线程或多进程处理来提高服务器的性能。
5. 支持Web应用程序框架，例如Node.js、Django等。
6. 支持缓存和负载均衡，以提高服务器的可扩展性和稳定性。
7. 支持WebSockets等新兴技术，以提供实时通信功能。

## 五、Debug Log

依旧会出现端口被占用的情况
查找相应进程的指令： ps -ef
删除进程：kill -9 PID

2023.2.17
这次进行的是，C连接数据库，设置多个路径的文件编译与拷贝，为了避免makefile的复杂，就写了两个makefile，需要先编译好cgi目录下的文件，再在上级目录中进行编译。
修复了运行脚本的BUG。

解决了上述端口异常占用的BUG，使用8081端口，终止程序使用ctrl+c，即不会出现端口异常占用

## 六、并发度测试

https://zhuanlan.zhihu.com/p/103423831

可以参考上述文章进行测试，不知道我的网站是否能成功。