## 一、简历上的技能回顾

### 1.1 项目框架

#### 1.1.1 自主web服务器

1. 使用**socket函数**创建一个TCP套接字，使用**bind函数**将其绑定到服务器的IP地址和端口号上，使用**listen函数**开始监听连接请求。
2. 使用**accept函数**接受客户端连接请求，并使用**recv函数**接收HTTP请求信息。
3. 解析HTTP请求信息，提取请求行、请求头和请求体等信息。
4. 根据请求信息生成相应的响应，包括状态行、响应头和响应体。
5. 使用**send函数**将响应信息发送回客户端，并关闭连接。

#### 1.1.2 高并发内存池

从上到下分为三层结构：**Thread Cache层**，**Centry Cache层**，**Page Cache层**。

线程与Thread Cache层交互从其中获取内存块，每个线程通过TLS技术获得独立的一份空间。

中间层负责为上层分配更多的空间，以及整合并回收上层释放的空间。如果空间不足，会向下层申请空间。

下层负责整合并回收中间层释放的空间，如果空间不够，会调用系统调用向操作系统申请空间。

及时整合并回收空间，可以减少内存外碎片的数量。

TLS技术和中间层的使用的桶锁能帮助线程快速申请和释放空间。

### 1.2 基本知识

#### 1.2.2 字节对齐

C语言**为了提高访问效率和节省内存空间**，对结构体成员进行调整，使得结构体成员的**起始地址都能对齐到某个特定的地址**（通常是4或8的倍数）。

字节对齐的规则如下：	

1. **结构体成员的起始地址必须是对齐值的整数倍**，否则会在该成员前面添加一些填充字节，使得该成员的起始地址对齐到对齐值的整数倍。

2. **结构体的总大小必须是对齐值的整数倍**，否则会在结构体最后添加一些填充字节，使得结构体的总大小对齐到对齐值的整数倍。

例如，下面的结构体在默认情况下，其大小为20字节：

```c
struct Test {
    char a;     // 1 byte
    int b;      // 4 bytes
    short c;    // 2 bytes
    double d;   // 8 bytes
};
```

但是，由于int和double类型的对齐值通常是4或8，因此编译器会在结构体成员之间添加一些填充字节，使得结构体成员的起始地址都对齐到4或8的倍数，从而使得结构体的大小为24字节。具体的字节对齐方式和填充字节的数量，取决于编译器的实现和编译选项。

可以通过编译器的特定选项来控制字节对齐的方式和对齐值，例如#pragma pack指令可以用于控制结构体成员的字节对齐方式和对齐值。

#### 1.2.3 大小端

大小端是指在计算机中，处理多字节数据时字节的排列方式。

在小端模式中，数据的低位字节存储在内存的低地址处，高位字节存储在内存的高地址处；而在大端模式中，数据的高位字节存储在内存的低地址处，低位字节存储在内存的高地址处。

以一个16位整数0x1234为例，它在内存中的排列方式如下：

- 小端模式：0x34存储在低地址处，0x12存储在高地址处。
- 大端模式：0x12存储在低地址处，0x34存储在高地址处。

在不同的计算机体系结构和操作系统中，可能采用不同的大小端模式。例如，x86架构的计算机通常采用小端模式，而PowerPC和SPARC架构的计算机通常采用大端模式。

在网络通信中，由于不同计算机的字节序可能不同，因此需要进行字节序的转换，以保证通信的正确性。常用的字节序转换函数包括htonl、htons、ntohl和ntohs等，它们可以将32位和16位整数在不同大小端模式之间进行转换。

#### 1.2.4 排序

- 快速排序

快速排序是一种基于分治思想的排序算法，其主要思想是选取一个基准元素，将序列中小于基准元素的元素放在其左边，大于基准元素的元素放在其右边，然后再对左右两部分分别进行快速排序，直到整个序列有序。

下面是C++实现快速排序的示例代码：

```cpp
void quickSort(vector<int>& nums, int left, int right) {
    if (left >= right) {  // 递归结束条件
        return;
    }
    int i = left, j = right;
    int pivot = nums[(left + right) / 2];  // 选择基准元素
    while (i <= j) {
        while (nums[i] < pivot) {  // 找到左边第一个大于等于基准元素的位置
            i++;
        }
        while (nums[j] > pivot) {  // 找到右边第一个小于等于基准元素的位置
            j--;
        }
        if (i <= j) {  // 交换左右两部分的元素
            swap(nums[i], nums[j]);
            i++;
            j--;
        }
    }
    quickSort(nums, left, j);   // 递归排序左半部分
    quickSort(nums, i, right);  // 递归排序右半部分
}
```

在以上代码中，参数`nums`表示待排序的数组，参数`left`和`right`表示数组的左右边界。函数首先判断左右边界是否重合，如果重合则返回，否则选择一个基准元素，将数组分为左右两部分，然后对左右两部分分别进行递归排序，直到整个序列有序。

在实际使用中，可以直接调用快速排序函数对整个数组进行排序，例如：

```cpp
vector<int> nums = {3, 5, 1, 10, 8, 9, 2, 4, 7, 6};
quickSort(nums, 0, nums.size() - 1);
for (int num : nums) {
    cout << num << " ";
}
```

输出结果为：1 2 3 4 5 6 7 8 9 10

快速排序的平均时间复杂度为O(nlogn)，空间复杂度为O(logn)，是一种比较高效的排序算法。

- 选择排序

选择排序是一种简单的排序算法，其主要思想是从待排序的序列中选择最小的元素，将其放在序列的起始位置，然后在剩余的序列中选择最小的元素，放在已排序序列的末尾，直到整个序列有序。

下面是C++实现选择排序的示例代码：

```cpp
void selectionSort(vector<int>& nums) {
    int n = nums.size();
    for (int i = 0; i < n - 1; i++) {
        int minIndex = i;  // 记录最小元素的下标
        for (int j = i + 1; j < n; j++) {
            if (nums[j] < nums[minIndex]) {
                minIndex = j;  // 更新最小元素的下标
            }
        }
        swap(nums[i], nums[minIndex]);  // 将最小元素放在已排序序列的末尾
    }
}
```

在以上代码中，参数`nums`表示待排序的数组。函数首先遍历整个数组，找到当前未排序序列中最小的元素，并将其放在已排序序列的末尾，重复这个过程直到整个序列有序。

在实际使用中，可以直接调用选择排序函数对整个数组进行排序，例如：

```cpp
vector<int> nums = {3, 5, 1, 10, 8, 9, 2, 4, 7, 6};
selectionSort(nums);
for (int num : nums) {
    cout << num << " ";
}
```

输出结果为：1 2 3 4 5 6 7 8 9 10

选择排序的时间复杂度为O(n^2)，空间复杂度为O(1)，虽然效率不如快速排序等高级排序算法，但它的实现简单，适用于小规模数据排序。

#### 1.2.4 进程间的通讯机制

进程间通讯（Interprocess Communication，IPC）是指在不同进程之间传输数据或信息的技术和方法。进程间通讯是多进程编程中非常重要的一部分，可以通过各种方式实现，常见的进程间通讯机制包括：

1. 管道（Pipe）：管道是一种半双工的通讯机制，可以在同一主机的两个进程之间传递数据，常用于父子进程之间的通讯。管道有匿名管道和命名管道两种类型，其中匿名管道只能在有亲缘关系的进程之间使用，而命名管道则可以在无亲缘关系的进程之间使用。

2. 共享内存（Shared Memory）：共享内存是一种高效的通讯机制，可以在不同进程之间共享同一块内存区域，从而实现数据的共享。共享内存需要进行进程同步操作，避免多个进程同时访问同一块内存区域造成的数据不一致问题。

3. 信号量（Semaphore）：信号量是一种计数器，可以用于进程之间的同步和互斥操作。通过信号量，进程可以协调访问共享资源的顺序，保证多个进程之间的数据访问正确性。

4. 消息队列（Message Queue）：消息队列是一种进程间的异步通讯机制，发送方将消息放入消息队列中，接收方从消息队列中获取消息。消息队列可以用于进程之间的通讯和同步操作。

5. 套接字（Socket）：套接字是一种通用的进程间通讯机制，可以在不同主机之间传递数据。套接字常用于网络编程中，可以实现不同主机之间的数据传输。

以上是常见的进程间通讯机制，不同的通讯机制适用于不同的应用场景，开发者需要选择适合自己应用的通讯机制进行开发。

#### 1.2.5 I/O 复用机制

I/O复用（Input/Output Multiplexing）是一种高效的I/O处理方式，它可以**让单线程同时处理多个I/O事件**。I/O复用机制可以通过以下几种方式实现：

1. select：select是最早的I/O复用机制，可以同时监听多个文件描述符的I/O事件，**当有I/O事件发生时，select会返回可读、可写或异常等事件**，进程可以根据返回结果进行相应的处理。**select的缺点是支持的文件描述符数量有限**，同时每次调用select时需要**将所有需要监听的文件描述符集合传递给内核，效率不高**。

2. poll：poll是select的改进版，可以监听更多的文件描述符，同时**支持动态添加和删除文件描述符**。poll的缺点是仍然需要将所有**需要监听的文件描述符集合传递给内核，效率不高**。

3. epoll：epoll是Linux中较新的I/O复用机制，可以监听大量的文件描述符，支持边缘触发和水平触发两种模式。**epoll将需要监听的文件描述符集合注册到内核中，每次调用epoll_wait时，内核会返回有事件发生的文件描述符，进程可以根据返回结果进行相应的处理。**epoll的优点是效率高，支持大量文件描述符，同时支持动态添加和删除文件描述符。

4. kqueue：kqueue是BSD系统中的I/O复用机制，类似于epoll，可以同时监听大量的文件描述符，支持动态添加和删除文件描述符。但kqueue与epoll的区别在于，kqueue可以同时监听I/O事件、信号事件和定时器事件等，具有更多的功能。

以上是常见的I/O复用机制，不同的复用机制适用于不同的应用场景，开发者需要选择适合自己应用的复用机制进行开发。

#### 1.2.6 网络协议

1. HTTP：HTTP（HyperText Transfer Protocol）是一种应用层协议，用于在Web浏览器和Web服务器之间传输超文本数据。HTTP使用TCP作为传输协议，通过请求-响应模型实现客户端与服务器之间的通信。HTTP请求包括请求行、请求头和请求体，而HTTP响应包括响应行、响应头和响应体。HTTP是互联网上最常用的协议之一，常用于网页浏览、文件下载等应用场景。

2. DNS：DNS（Domain Name System）是一种分布式数据库系统，用于将域名转换为IP地址。DNS将域名分层管理，由多个DNS服务器组成，每个DNS服务器负责管理一部分域名。当用户输入一个域名时，本地DNS服务器会先查询自身的缓存，如果缓存中没有相关记录，则向上级DNS服务器发送查询请求，直到找到对应的IP地址。DNS是互联网上最重要的基础设施之一，所有的互联网应用都依赖于DNS系统。

3. ARP：ARP（Address Resolution Protocol）是一种用于将IP地址转换为物理地址（MAC地址）的协议。当主机需要向另一个主机发送数据时，需要知道目标主机的MAC地址，这时候就需要使用ARP协议进行地址解析。ARP会向本地网络中的所有主机发送ARP请求，请求中包含目标IP地址，如果有主机的IP地址与请求中的目标IP地址匹配，则该主机会返回自己的MAC地址。ARP协议是TCP/IP协议族中的一部分，常用于局域网中的通信。

## 二、测开

### 2.1 百度

自我介绍

聊了下我的爱好diy电脑？？？

项目介绍：整体框架，功能

问了下项目中遇到最大的困难，我说我发现了gdb调试多线程进程太麻烦了，解决方式是用了条件判断捕获错误

一个网址输入后发生了什么（感觉我答的不咋滴，就说了七层模型的功能，还有加减报头的过程，三次握手都忘了说）

c和c++区别

构造函数

深浅拷贝

类和结构体的内存对齐

利用栈模拟实现队列，思路（是栈A存入队的，栈B存出队的吧）

the sky is blue. -> blue. is sky the 思路（高效的我不会，逆置再逆置）

多态的理解，聊到了虚表（我忘了。。。）

二叉树的遍历方式，没让详细说

智能指针之shared_ptr，以及引用计数是如何实现线程安全的，空间在栈上还是堆上

Linux十个命令

Linux通过端口号查到进程（我只知道ps，结果是netstat）

Linux查询进程部署在哪个路径（我不会）

git解决分支冲突（我说的git branch 切换分支然后删冲突分支，姐姐说简单点直接删冲突的地方）



对测试开发岗位的理解

测试自己的web服务器怎么测试，提到白盒测试（我不知道），聊到postman接口测试（我瞎糊说好像说对了）

聊到怎么学习新技术（我说我让生成式ai告诉我学习资源，一般都是些官方文档，然后我说我在学docker就这样的，姐姐也说docker经常要用）



姐姐介绍了一下业务

开发的搞机器学习推荐业务，测试的负责测试（这可能也是为啥没问我机器学习的内容）

我问开发和测试怎么配合工作



我问几次面试（第一次基础面，第二次业务面，第三次HR面）

#### 2.1.1 职位要求及面试问题

岗位职责

"-参与机器学习相关项目的测试工作，制定项目测试方案，计划并实施，保证项目质量和进度

-设计与执行测试用例，跟踪定位产品软件中的缺陷或问题

-参与产品需求、系统设计和程序代码的评审工作，并提出改进意见

-根据产品和项目特点，提出合理的自动化解决方案，并负责设计和实现自动化测试工具，提高测试效率

-评估项目质量风险，与产品经理和开发人员就项目进度和问题进行沟通"

岗位要求

"-计算机或计算机相关专业学士及以上学历

-扎实的Linux/Unix平台上的C/C++编程基础，了解网络编程、多线程编程

-扎实的算法和数据结构基础，对机器学习常用算法有了解

-有擅长的脚本语言，如shell、python等

-了解大规模数据挖掘、机器学习、自然语言处理、分布式计算等相关技术

-了解机器学习基本算法的设计思想和求解手段，如DNN，GNN等。有大规模机器学习系统研发经验或机器学习算法优化理论的研究经验者优先

-良好的抗压能力，能应对项目中的各种挑战

-具有良好的沟通表达能力、团队合作意识、坦诚直接"

-2024届岗位

1. 您有哪些机器学习项目的经验？可以分享一些您在这些项目中所遇到的挑战和解决方案吗？
2. 您能否解释一下什么是机器学习？您能简要介绍一下机器学习的基本概念和常用算法吗？
3. 您最擅长的编程语言是什么？您如何在编程中遵循最佳实践和代码规范？
4. 您在设计和执行测试用例时通常会考虑哪些因素？您如何评估测试结果和发现的问题？
5. 您如何处理在测试中发现的紧急问题和缺陷？您如何与开发人员和产品经理进行沟通和协调？
6. 您是否有自动化测试经验？您通常使用哪些自动化测试工具和框架？
7. 您是否了解分布式计算和大规模数据处理技术？您能分享一些您在这些领域的经验和见解吗？
8. 您如何处理在快节奏的工作环境中的压力和挑战？您如何管理和组织您的工作？
9. 您能描述一下您在之前的工作中遇到的最具挑战性的项目或任务，并介绍您是如何解决它们的？
10. 您如何自我学习和不断提高自己的技能？您通常使用哪些资源和工具来保持自己的学习和发展？

#### 2.1.2 你可以问面试官

1. 您们的团队通常是如何与开发团队协作的，以确保测试和开发工作的顺利进行？
2. 您们如何评估项目质量风险，以及如何应对这些风险？
3. 您们如何设计测试用例，以检测机器学习系统中的各种错误和异常？
4. 您们如何设计和实现自动化测试工具来提高测试效率？在实现自动化测试时，您们主要采用哪些技术？
5. 您们如何评估机器学习算法的性能，以及如何优化它们的性能？
6. 您们如何与产品经理和开发人员进行沟通，以确保项目的顺利进行和问题的解决？
7. 除了机器学习技能，您们更看重实习生的哪些技能和素质？
8. 您们的团队是如何组织和管理测试工作的，以确保测试和开发进度的同步和协调？
9. 在测试工作中，您们通常会使用哪些工具和软件？您们如何评估新工具和软件的适用性？
10. 您们如何进行代码评审和改进？评审和改进的标准是什么？

#### 2.1.3 针对岗位要求

##### Linux网络编程

Linux网络编程是指在Linux操作系统上开发网络应用程序的过程，包括利用网络协议进行通信、使用套接字进行数据传输、处理网络事件等方面的内容。

Linux网络编程的特点包括：

1. 基于套接字：Linux网络编程主要**基于套接字（Socket）进行网络通信**，套接字是一种抽象的通信机制，可以实现不同计算机之间的数据传输。
2. 支持多种协议：Linux**支持多种网络协议**，如TCP/IP、UDP、HTTP、SMTP等，可以根据需要选择适合的协议进行通信。
3. 高效稳定：Linux网络编程采用**异步和非阻塞**的方式进行数据传输，可以提高网络通信的效率和稳定性。
4. 面向对象：Linux网络编程可以采用面向对象的设计模式，使用C++语言进行开发，提高代码的可读性和可维护性。
5. 开源免费：Linux网络编程的开发环境和工具都是开源免费的，可以方便地获取和使用。

在Linux网络编程中，常用的编程语言包括C、C++、Python等。开发者可以利用Linux系统提供的网络编程库，如Socket、TCP/IP协议栈等进行网络编程。

Linux网络编程的应用非常广泛，包括Web服务器、邮件服务器、数据库服务器等，还可以用于开发各种网络应用程序，如聊天室、在线游戏、远程控制等。掌握Linux网络编程技能对于网络开发人员来说是非常重要的。

##### 多线程编程

Linux中的多线程编程指的是在Linux系统下使用多线程机制进行程序开发。多线程是指在同一进程中同时执行多个线程的机制，每个线程都可以独立执行不同的任务，共享进程的资源，如内存、文件等。

Linux中的多线程编程主要**采用POSIX线程库（pthread）**进行开发，这是一个标准的多线程库，提供了一组API函数，可以方便地创建、管理和同步多个线程。POSIX线程库在Linux系统中默认安装，开发者不需要额外安装任何软件。

Linux中的多线程编程有以下特点：

1. 轻量级：线程在同一进程中共享资源，线程的创建和销毁开销较小，可以减少系统资源的消耗。
2. 高效性：线程可以在同一进程内直接进行通信和数据共享，线程间切换的开销较小，可以提高程序性能。
3. 可移植性：Linux中的多线程编程采用POSIX线程库，可以在不同操作系统间进行移植。
4. 灵活性：多线程编程可以充分利用多核CPU的优势，提高程序并发处理能力。

在Linux中，多线程编程可以应用于各种场景，如网络编程、图形界面编程、数据处理等。开发者可以利用多线程机制来实现并发执行的任务，提高程序的效率和响应速度。

需要注意的是，在多线程编程中要处理好线程之间的同步和互斥问题，避免线程之间的竞争和冲突。常用的同步和互斥机制包括互斥锁、条件变量、信号量等。

###### 使用互斥锁来避免线程之间的竞争和冲突

使用互斥锁（Mutex）是一种常用的**同步**机制，可以避免多个线程同时访问共享资源而导致的冲突和竞争。下面以C语言为例，简单介绍如何使用互斥锁来保护共享资源。

首先，需要定义一个互斥锁变量，可以使用pthread_mutex_t类型来定义：

```c
pthread_mutex_t mutex;
```

接下来，在需要保护共享资源的地方，使用pthread_mutex_lock函数来加锁，防止其他线程同时访问该资源：

```c
pthread_mutex_lock(&mutex);
// 访问共享资源
pthread_mutex_unlock(&mutex);
```

在访问共享资源的代码块前使用pthread_mutex_lock函数加锁，然后在代码块后使用pthread_mutex_unlock函数释放锁。当一个线程获取了锁后，其他线程需要等待该线程释放锁才能访问共享资源，从而避免了竞争和冲突。

最后，在程序结束前需要销毁互斥锁变量，使用pthread_mutex_destroy函数释放资源：

```c
pthread_mutex_destroy(&mutex);
```

完整的互斥锁使用示例代码如下：

```c
#include <pthread.h>
#include <stdio.h>

pthread_mutex_t mutex;
int counter = 0;

void *thread_func(void *arg) {
    int i;
    for (i = 0; i < 10000; i++) {
        pthread_mutex_lock(&mutex);
        counter++;
        pthread_mutex_unlock(&mutex);
    }
    return NULL;
}

int main() {
    pthread_t thread1, thread2;
    pthread_mutex_init(&mutex, NULL);
    pthread_create(&thread1, NULL, thread_func, NULL);
    pthread_create(&thread2, NULL, thread_func, NULL);
    pthread_join(thread1, NULL);
    pthread_join(thread2, NULL);
    pthread_mutex_destroy(&mutex);
    printf("counter = %d\n", counter);
    return 0;
}
```

在该示例中，创建了两个线程访问同一个计数器变量，由于计数器是共享资源，因此需要使用互斥锁进行保护。在线程函数中，使用pthread_mutex_lock函数加锁，然后访问计数器变量，使用pthread_mutex_unlock函数释放锁。在程序结束前，使用pthread_mutex_destroy函数释放资源。

通过使用互斥锁，可以保证计数器变量在多个线程中被正确地增加，避免了竞争和冲突。



以下是使用pthread库进行多线程编程的例子：

1. 创建线程

```c
#include <pthread.h>
#include <stdio.h>

void *print_message(void *ptr) {
    char *message;
    message = (char *) ptr;
    printf("%s \n", message);
}

int main() {
    pthread_t thread1, thread2;
    char *message1 = "Thread 1";
    char *message2 = "Thread 2";
    int iret1, iret2;

    iret1 = pthread_create(&thread1, NULL, print_message, (void*) message1);
    iret2 = pthread_create(&thread2, NULL, print_message, (void*) message2);

    pthread_join(thread1, NULL);
    pthread_join(thread2, NULL);

    return 0;
}
```

2. 互斥锁

```c
#include <pthread.h>
#include <stdio.h>

int count = 0;
pthread_mutex_t mutex;

void *increment_count(void *ptr) {
    int i;
    pthread_mutex_lock(&mutex);
    for (i = 0; i < 100000; i++) {
        count++;
    }
    pthread_mutex_unlock(&mutex);
}

int main() {
    pthread_t thread1, thread2;
    pthread_mutex_init(&mutex, NULL);
    pthread_create(&thread1, NULL, increment_count, NULL);
    pthread_create(&thread2, NULL, increment_count, NULL);
    pthread_join(thread1, NULL);
    pthread_join(thread2, NULL);
    pthread_mutex_destroy(&mutex);
    printf("Count: %d\n", count);
    return 0;
}
```

3. 条件变量

```c
#include <pthread.h>
#include <stdio.h>

pthread_mutex_t mutex;
pthread_cond_t cond;
int count = 0;

void *increment_count(void *ptr) {
    int i;
    pthread_mutex_lock(&mutex);
    for (i = 0; i < 100000; i++) {
        count++;
    }
    if (count == 200000) {
        pthread_cond_signal(&cond);
    }
    pthread_mutex_unlock(&mutex);
}

int main() {
    pthread_t thread1, thread2;
    pthread_mutex_init(&mutex, NULL);
    pthread_cond_init(&cond, NULL);
    pthread_create(&thread1, NULL, increment_count, NULL);
    pthread_create(&thread2, NULL, increment_count, NULL);
    pthread_mutex_lock(&mutex);
    while (count < 200000) {
        pthread_cond_wait(&cond, &mutex);
    }
    pthread_mutex_unlock(&mutex);
    pthread_join(thread1, NULL);
    pthread_join(thread2, NULL);
    pthread_mutex_destroy(&mutex);
    pthread_cond_destroy(&cond);
    printf("Count: %d\n", count);
    return 0;
}
```

以上是几个使用pthread库进行多线程编程的例子，开发者可以根据自己的需求进行选择和修改。

#### 2.1.4 面经

##### 2.1.4.1 自我介绍

在面试中，一个简短的自我介绍是非常重要的，它可以让招聘者更好地了解你的个人情况和职业背景。以下是一个简短自我介绍的常用模板，你可以根据自己的情况进行适当的修改：

1. 开场白：你好，我是XXX，很高兴参加此次面试。
2. 职业背景：我具有X年的XXX经验，曾在XXX公司担任XXX职位。
3. 技能介绍：我熟练掌握XXX技能，如XXX、XXX等；同时，我还具备良好的XXX技能，如XXX、XXX等。
4. 成就介绍：在之前的工作中，我成功完成了XXX项目，取得了XXX成果，对公司产生了XXX的贡献。
5. 意向介绍：我对贵公司的XXX职位非常感兴趣，相信我可以为公司做出贡献。
6. 结尾：非常感谢您的时间，期待有机会加入贵公司。

需要注意的是，简短自我介绍的重点是突出自己的优势和成就，同时要紧扣面试职位的要求，让招聘者对你的能力和适合程度有一个初步的了解。同时，语言要简洁明了，避免过于冗长和复杂，以免影响面试官的理解和印象。



**demo**

面试官您好，我是鄢飞宇，很高兴参加此次面试。我目前是一名大三的学生，我主要了解C/C++/数据结构/Linux/Mysql等相关知识。我对贵公司的测试开发职位非常感兴趣，期待有机会加入贵公司。



##### 2.1.4.2 HashMap的底层数据结构

在C++中，HashMap的底层数据结构是**哈希表（Hash Table**），它采用了**数组和链表**的数据结构来存储数据。具体来说，HashMap的底层数据结构由以下两部分组成：

1. 数组（Array）：HashMap内部维护了一个大小为N的数组，其中N是HashMap的容量大小。**数组的每个元素称为桶**（Bucket），每个桶可以存储一个或多个键值对。
2. 链表（Linked List）：当多个键映射到同一个桶时，**HashMap采用链表来存储这些键值对**。具体来说，每个桶都维护一个链表，链表中的每个节点存储一个键值对。

**当需要往HashMap中添加一个键值对时，HashMap会先通过哈希函数计算键的哈希值，然后根据哈希值找到对应的桶**。**如果该桶中已经存在一个键值对，则遍历链表，查找是否已经存在相同的键，如果存在，则更新对应的值；如果不存在，则在链表末尾添加一个新的节点。如果该桶中不存在任何键值对，则直接在该桶中添加一个新的节点。**

当需要查找一个键值对时，HashMap也会先通过**哈希函数**计算键的哈希值，然后找到对应的桶，遍历桶中的链表，查找是否存在该键，如果存在，则返回对应的值；如果不存在，则返回null。

需要注意的是，当链表中的节点数量过多时，会导致查找效率降低，因此C++11之后的版本中，当链表长度达到一定阈值（默认为8）时，会将链表转化为红黑树，以提高查找效率。此外，C++标准库中还提供了unordered_map类，它是基于哈希表实现的映射容器，提供了类似于HashMap的功能。

##### 2.1.4.3 什么是Hash冲突，以及几种解决的方法

**Hash冲突指的是不同的键在哈希表中被映射到了同一个桶中的情况**。由于哈希表中每个桶只能存储一个键值对，因此如果多个键被映射到同一个桶中，就会导致数据丢失或者查找错误的问题。Hash冲突是哈希表必然会遇到的问题，因此需要采取一些方法来解决。

以下是几种常见的Hash冲突解决方法：

1. 链表法（Chaining）：当发生Hash冲突时，**将冲突的键值对存储在同一个桶中的链表中**。在查找时，遍历链表即可。
2. 开放地址法（Open Addressing）：当发生Hash冲突时，**将键值对存储在离冲突桶最近的空桶中**。具体的方法包括**线性探测、二次探测、双重散列**等。
3. 公共溢出区法（Overflow Area）：在哈希表中维护一个公共溢出区，将发生Hash冲突的键值对都存储在这个区域中。在查找时，先在桶中查找，如果没有找到，则到公共溢出区中查找。

需要注意的是，以上方法都有各自的优缺点。例如，链表法可以有效解决Hash冲突，但是当链表过长时，会导致查找效率降低。开放地址法可以避免链表过长的问题，但是需要处理好冲突时的探测步长，否则也会导致性能下降。公共溢出区法虽然可以避免链表过长和探测步长的问题，但是需要额外的空间来维护溢出区，会导致空间浪费。因此，在选择哈希冲突解决方法时，需要根据实际情况进行权衡。

##### 2.1.4.4 post的请求格式

在HTTP（Hypertext Transfer Protocol）中，POST方法用于向服务器提交数据，例如表单数据、文件等，以便进行处理或保存到服务器中。以下是POST请求的格式：

1. **请求行**（Request Line）：与GET请求相同，POST请求的第一行为请求行，格式为：POST /path/to/resource HTTP/1.1

其中，/path/to/resource为请求资源的路径。

2. **请求头**（Request Headers）：在请求行之后，可以包含多个请求头，用来描述请求的一些信息，例如Content-Type、Content-Length等。其中，最常用的请求头是Content-Type，用来指定请求体中数据的类型。

3. **请求体**（Request Body）：POST请求的数据通常包含在请求体中，请求体可以是任何格式的数据，例如表单数据、JSON、XML、二进制数据等。请求体的格式和内容由Content-Type请求头指定。

以下是一个POST请求的示例：

```
POST /api/user HTTP/1.1
Host: example.com
Content-Type: application/json
Content-Length: 52

{
  "name": "John Smith",
  "email": "john@example.com",
  "password": "password123"
}
```

在上述示例中，POST请求的路径为/api/user，请求头包含了Host、Content-Type、Content-Length等信息，请求体为一个JSON格式的数据。

##### 2.1.4.5 get和post的区别

GET和POST是HTTP（Hypertext Transfer Protocol）中最常用的两种请求方法，它们在使用场景、请求参数、请求体等方面有以下区别：

1. 使用场景：

**GET方法通常用于请求服务器返回某个资源，例如获取网页、图片等**。它是一种幂等（Idempotent）的请求方法，也就是说，对同一个URL地址进行多次GET请求，得到的结果应该是相同的。

**POST方法通常用于向服务器提交数据，例如表单数据、文件等**，以便进行处理或保存到服务器中。它是一种非幂等（Non-Idempotent）的请求方法，也就是说，对同一个URL地址进行多次POST请求，得到的结果可能不同。

2. 请求参数：

**GET方法的请求参数通常使用URL参数（Query String）的方式传递**，**即将参数拼接在URL的末尾**，例如：http://example.com/path?name=value&age=18。

**POST方法的请求参数通常使用请求体（Request Body）的方式传递**，**即将参数放在请求体中进行提交**，例如通过表单提交的数据。

3. 请求体：

**GET方法不允许发送请求体**，因为它的作用是获取资源，请求体通常没有意义。

**POST方法允许发送请求体**，因为它的作用是向服务器提交数据，请求体通常包含了需要提交的数据。

4. 安全性：

GET方法的请求参数和URL参数都是**明文传输**的，安全性较低，因此不适合发送敏感信息。

POST方法的请求参数和请求体是**加密传输**的，安全性较高，适合发送敏感信息。

需要注意的是，GET和POST方法的使用场景是有一定的交叉性的，也就是说，有些请求既可以使用GET方法，也可以使用POST方法。在实际应用中，应根据具体的情况选择合适的请求方法。

##### 2.1.4.6 mysql事务隔离等级

MySQL数据库支持四种事务隔离级别，分别为：读未提交（Read Uncommitted）、读已提交（Read Committed）、可重复读（Repeatable Read）和串行化（Serializable）。

1. 读未提交（Read Uncommitted）：最低的事务隔离级别，允许事务读取未提交的数据。在该隔离级别下，一个事务可以读取另一个事务尚未提交的数据，容易导致脏读、不可重复读和幻读等问题。
2. 读已提交（Read Committed）：在该隔离级别下，一个事务只能读取已经提交的数据。在该级别下，可以避免脏读问题，但是可能出现不可重复读和幻读问题。
3. 可重复读（Repeatable Read）：在该隔离级别下，一个事务在执行期间读取的数据始终保持一致。在该级别下，可以避免脏读和不可重复读问题，但是可能出现幻读问题。
4. 串行化（Serializable）：在该隔离级别下，一个事务完全串行化执行，避免了所有的并发问题，包括脏读、不可重复读和幻读等问题。但是，串行化会带来很大的性能开销，因此不适合在高并发的场景下使用。

需要注意的是，不同的隔离级别对性能和数据完整性都有一定的影响，应根据具体的业务场景选择合适的隔离级别。在实际应用中，一般使用默认的隔离级别（可重复读），或者根据具体的业务需要选择其他的隔离级别。

在多个事务并发执行的情况下，可能会出现以下三种问题：

1. 脏读（Dirty Read）：一个事务读取了另一个事务尚未提交的数据，导致数据不一致。如果另一个事务最终回滚了，那么读取的数据就是无效的。
2. 不可重复读（Non-Repeatable Read）：一个事务在同一时间内**多次读取同一行数据**，但是却得到了不同的结果，导致数据不一致。这是因为在这个时间段内，另一个事务修改了这行数据并提交了。
3. 幻读（Phantom Read）：一个事务在同一时间内**多次执行同一条SQL语句**，但是却得到了不同的结果，导致数据不一致。这是因为在这个时间段内，另一个事务插入了新的数据或者删除了已有的数据。



##### 2.1.4.7 常用Linux指令

查看日志、查看进程，关闭进程和查看进程cpu占用率的Linux指令是什么

以下是 Linux 中常用的几个命令：

1. 查看日志：`tail` 命令可以查看文件的末尾内容，常用于查看日志文件。如 `tail -f /var/log/messages` 可以实时查看 `/var/log/messages` 的日志内容。
2. 查看进程：`ps` 命令可以查看系统的进程列表。如 `ps -ef` 可以列出系统中所有进程的详细信息。
3. 关闭进程：`kill` 命令可以关闭指定的进程。如 `kill 1234` 可以关闭进程号为 1234 的进程。
4. 查看进程 CPU 占用率：`top` 命令可以实时查看系统的进程信息，包括 CPU 占用率等。如 `top -c` 可以按照进程名进行分类，并显示每个进程的 CPU 占用率。

需要注意的是，以上命令的使用方法还有很多参数和选项，可以根据具体的需求进行调整。



##### 2.1.4.8 C中的struct和C++中的struct

在 C++ 中，`struct` 可以继承其他类或结构体，从而拥有更多的**面向对象特性。**

C没有权限属性，C++的struct是默认public

##### 2.1.4.9 C++的class和struct的区别。

C++ 中的 `class` 和 `struct` 最主要的区别在于默认访问权限不同。在 `class` 中，默认成员是私有的，而在 `struct` 中，默认成员是公共的。因此，`class` 更适合用于实现面向对象的封装，而 `struct` 更适合用于组织数据。

##### 2.1.4.10 引用和指针的区别

引用和指针都可以用于间接访问变量。不同之处在于，**引用在定义时必须初始化**，而**指针可以先定义再赋值**。引用在使用时更加**方便**，不需要使用解引用符号 *，而且不能指向空值。指针则更加**灵活**，可以进行指针运算、指向数组或函数等。

##### 2.1.4.11 在一个文件中定义一个static全局变量的作用，范围是什么？

在一个文件中定义一个 `static` 全局变量的作用是限制该变量的作用域只在当前文件中，不会对其他文件产生影响。该变量的生命周期与程序的运行时间相同，但只能在当前文件中访问。

##### C++函数值传递几种方式

C++ 函数值传递有三种方式：**传递基本数据类型、传递指针、传递引用**。传递基本数据类型时，函数接收的是实参的副本，不会改变实参的值；传递指针或引用时，函数可以修改实参的值；引用比指针更加简洁方便，且更加安全。

##### 声明阶段#define和const相比，const有什么好处。

在声明阶段，`#define` 和 `const` 的主要区别在于**类型检查和作用域**。`#define` 宏定义没有类型检查，可以定义任何东西，容易出错；而 `const` 变量有类型检查，只能定义指定类型的变量。此外，`#define` 宏定义没有作用域限制，可以在任何地方使用；而 `const` 变量的作用域是块级作用域，只能在声明它的块中使用。

##### C++的类型安全问题。

C++ 中的类型安全问题主要包括**类型转换和指针操作**。类型转换可能会导致精度损失、溢出等问题，需要谨慎使用；指针操作容易出现空指针、野指针等问题，需要注意指针的初始化和释放。

##### 内存分配的方式。

在 C++ 中，有四种内存分配方式：静态存储、自动存储、动态存储和栈存储。

1. **静态存储**：指在**程序编译时就已经分配好的存储空间**，例如**全局变量和静态局部变量**。这些变量的存储空间在程序运行时一直存在，直到程序结束才被释放。
2. **自动存储**：指在**函数内部定义的变量，每次函数调用时会重新分配存储空间**。这些变量的存储空间在函数调用结束后被释放。
3. **动态存储**：指在**程序运行时根据需要动态分配的存储空间**，例如**使用 `new` 和 `delete` 运算符分配和释放的存储空间**。动态存储空间的生存期由程序员控制，需要手动释放以避免内存泄漏。
4. **栈存储**：指**函数调用时使用的一块连续的内存空间，用于存储函数的参数、返回地址和局部变量**等信息。栈存储由编译器自动管理，函数调用结束后栈空间会自动释放。

##### 函数重载，重写和重定义。

C++ 中的函数重载、重写和重定义是三个不同的概念，它们在语法和语义上都有所区别。

1. 函数重载（Function Overloading）

函数重载是指在同一个作用域内定义多个函数，它们**具有相同的名称但参数列表不同**。编译器根据调用时的参数列表来决定调用哪个函数。函数重载可以提高代码的复用性和可读性。

示例代码：
```cpp
int add(int a, int b) {
  return a + b;
}

double add(double a, double b) {
  return a + b;
}

int main() {
  int sum1 = add(1, 2);
  double sum2 = add(1.0, 2.0);
  return 0;
}
```

2. 函数重写（Function Overriding）

函数重写是指派生类中定义了一个**与基类中同名、同参数列表、同返回类型的虚函数**，并且使用 `override` 关键字标识。在程序运行时，当通过基类指针或引用调用该函数时，实际上调用的是派生类中的函数。函数重写实现了多态性，是面向对象程序设计中的重要概念。

示例代码：
```cpp
class Shape {
public:
  virtual double area() {
    return 0.0;
  }
};

class Circle : public Shape {
public:
  double area() override {
    return 3.14 * radius * radius;
  }
private:
  double radius;
};

int main() {
  Shape* s = new Circle();
  double area = s->area(); // 调用 Circle::area()
  return 0;
}
```

3. 函数重定义（Function Redefinition）

函数重定义是指在同一个作用域内定义了多个名称、参数列表相同但函数体不同的函数。函数重定义是不合法的，会导致编译错误。

示例代码：
```cpp
int add(int a, int b) {
  return a + b;
}

int add(int a, int b) { // 错误：函数重定义
  return a - b;
}

int main() {
  int sum = add(1, 2);
  return 0;
}
```

总之，函数重载、重写和重定义是 C++ 中的三个不同概念，需要根据语境和需要选择合适的方式使用。

##### 在Linux操作系统中，再不打开一个文件的条件下，查看指定第十行的大小。

可以使用Linux中的sed命令来实现在不打开文件的情况下查看指定行的内容，具体命令如下：

```
sed -n '10p' filename | wc -c
```

其中，`-n` 表示不输出模式空间的内容，`10p` 表示输出第十行的内容，`filename` 是要查看的文件名。`| wc -c` 表示计算输出的字符数，即第十行的大小。

注意，如果文件中有多个换行符，那么第十行的大小可能会比实际的大。如果要避免这种情况，可以在 sed 命令中加上 `-e` 选项，强制使用 POSIX 输出模式，具体命令如下：

```
sed -ne '10{p;q;}' filename | wc -c
```

其中，`-e` 选项表示使用 POSIX 输出模式，`10{p;q;}` 表示输出第十行的内容并退出，`filename` 是要查看的文件名。`| wc -c` 表示计算输出的字符数，即第十行的大小。

除了使用 `sed` 命令，还有一些其它方法可以在不打开文件的情况下查看指定行的大小：

1. 使用 `head` 命令和 `tail` 命令：**可以使用 `head` 命令查看文件的前十行，然后使用 `tail` 命令查看前十行中的最后一行**，具体命令如下：

   ```
   head -n 10 filename | tail -n 1 | wc -c
   ```

   其中，`-n 10` 表示查看文件的前十行，`tail -n 1` 表示查看前十行中的最后一行，`filename` 是要查看的文件名。`| wc -c` 表示计算输出的字符数，即第十行的大小。

2. 使用 `awk` 命令：可以使用 `awk` 命令查看指定行的内容，然后使用 `length()` 函数获取行的大小，具体命令如下：

   ```
   awk 'NR==10{print length($0)}' filename
   ```

   其中，`NR==10` 表示查看第十行的内容，`print length($0)` 表示输出行的大小，`filename` 是要查看的文件名。

无论使用哪种方法，都可以在不打开文件的情况下查看指定行的大小。

##### Linux操作系统中，有一个大文件（比内存大，不能进行展开），不能一次性打开。

在 Linux 操作系统中，如果要处理一个大文件，但又不能一次性打开，可以考虑使用以下方法：

1. 分割文件：可以使用 `split` 命令将大文件分割成多个小文件，然后逐个处理小文件。具体命令如下：

   ```
   split -b 1G filename filename_part
   ```

   其中，`-b 1G` 表示将文件按照 1GB 的大小进行分割，`filename` 是要分割的文件名，`filename_part` 是分割后的文件名前缀。

2. 使用管道：可以使用管道（`|`）将多个命令组合起来，逐个处理文件的部分。具体命令如下：

   ```
   cat filename | command1 | command2 | ... | commandN
   ```

   其中，`filename` 是要处理的文件名，`command1`、`command2`、...、`commandN` 是处理文件的命令，多个命令之间用管道连接。

3. 使用缓存：可以使用缓存将部分文件读入内存中进行处理，然后再读入下一部分文件。具体命令如下：

   ```
   tail -f filename | command
   ```

   其中，`filename` 是要处理的文件名，`tail -f` 命令可以将文件的最后部分实时输出，`command` 是处理文件的命令。

通过以上方法，可以逐个处理大文件的部分，避免一次性打开大文件导致系统崩溃或程序运行缓慢。

##### MySQL事务的特性

MySQL的事务（Transaction）是指一组SQL语句，它们被当作一个单独的工作单元来执行。在MySQL中，事务具有以下四个特性（ACID）：

1. 原子性（Atomicity）：事务是一个原子操作，即**事务中的所有操作要么全部完成，要么全部不完成**，不会出现部分完成的情况。如果事务中的任何一个**操作失败，则整个事务都会被回滚到事务开始前的状态**，以保证数据的一致性。

2. 一致性（Consistency）：事务执行后，数据库的状态应该是从一个一致性的状态转移到另一个一致性的状态。在事务执行期间，数据库中的数据应该始终满足一定的约束规则，如**主键唯一、外键引用完整性**等。

3. 隔离性（Isolation）：事务之间是相互隔离的，即**一个事务的执行不应该影响到另一个事务的执行**。多个事务并发执行时，每个事务都应该感觉不到其他事务的存在。为了实现隔离性，MySQL提供了四种隔离级别：读未提交（Read Uncommitted）、读已提交（Read Committed）、可重复读（Repeatable Read）和串行化（Serializable）。

4. 持久性（Durability）：事务一旦提交，它对数据库中的数据的**改变就是永久性**的，即使系统崩溃，已提交的事务对数据库中的数据的改变也不会丢失。

##### 怎么提升一个SQL语句的查询效率

提升 SQL 查询效率的方法有很多，下面列举一些常见的方法：

1. **使用索引**：索引可以大大提高 SQL 查询的效率，可以**使用 `CREATE INDEX` 命令在需要的列上创建索引**，以加速查询。需要注意的是，**索引不是越多越好**，过多的索引可能会降低查询效率，因此需要根据实际情况选择合适的索引。

2. 优化查询语句：可以通过分析查询语句，优化其中的 SQL 语句结构、查询条件、列选择等，来提高查询效率。例如，可以**避免使用 `SELECT *`，尽量只选择需要的列；避免使用子查询等复杂的查询语句；使用 `JOIN` 代替多个查询语句等。**

3. 使用缓存：可以**使用缓存来避免重复查询相同的数据**，从而提高查询效率。例如，可以使用 MySQL 的查询缓存，将查询结果缓存到内存中，下次查询相同的数据时直接从缓存中读取。

4. 分区查询：对于大型表，可以采用分区查询的方式，**将表分成多个独立的分区，以减少查询时需要扫描的数据量**，从而提高查询效率。

5. 优化数据库结构：可以通过优化数据库结构，如表设计、数据类型选择等，来减少数据库的存储空间，提高查询效率。例如，可以**使用整型代替字符串类型存储数据，减少存储空间；将冗余数据拆分成独立的表等**。

##### 编程，输出一个字符串的最大无重复子字符串。

以下是一个 C++ 程序，可以输出一个字符串的最大无重复子字符串：

```cpp
#include <iostream>
#include <cstring>
#include <unordered_set>

using namespace std;

string maxUniqueSubstring(string str) {
    int n = str.length();
    unordered_set<char> s;
    int left = 0, right = 0;
    int maxLen = 0, leftIndex = 0, rightIndex = 0;
    while (right < n) {
        if (s.find(str[right]) == s.end()) {
            s.insert(str[right]);
            right++;
            if (right - left > maxLen) {
                maxLen = right - left;
                leftIndex = left;
                rightIndex = right;
            } 
        } else {
            s.erase(str[left]);
            left++;
        }
    }
    return str.substr(leftIndex, maxLen);
}

int main() {
    string str = "abcabcbb";
    cout << "The maximum unique substring of " << str << " is " << maxUniqueSubstring(str) << endl;
    return 0;
}
```

这个程序的基本思路是使用双指针维护一个窗口，窗口内的字符都是不重复的。具体实现中，使用一个哈希集合来存储窗口内的字符，如果新加入的字符不在集合中，则将其加入窗口，并更新最大无重复子字符串的长度和位置；如果新加入的字符已经在集合中，则从窗口左侧开始删除字符，直到窗口内不再有重复字符为止。



##### 测试一个登录界面

测试登录界面需要关注以下几个方面：

1. 功能测试：测试登录功能是否正常，包括输入正确的用户名和密码时是否能够成功登录，输入错误的用户名或密码时是否能够提示相应的错误信息，是否能够防止暴力破解等。

2. 安全测试：测试是否存在安全漏洞，例如是否能够通过 SQL 注入、XSS 攻击等方式绕过登录验证，是否存在密码泄露等风险。

3. 兼容性测试：测试登录界面在不同的浏览器和操作系统下是否能够正常运行，是否能够适配不同的屏幕分辨率和设备类型。

4. 用户体验测试：测试登录界面的用户友好性和易用性，例如登录界面的布局是否合理、输入框的提示信息是否清晰明了、登录按钮的响应时间是否够快等。

以下是一些常用的测试方法和技术：

1. 功能测试：使用黑盒测试方法，测试输入正确和错误的用户名和密码时的登录结果，包括登录成功、登录失败和错误提示信息等。

2. 安全测试：使用渗透测试方法，测试是否能够绕过登录验证、注入恶意代码等。

3. 兼容性测试：使用自动化测试工具和不同的浏览器和操作系统进行测试，例如使用 Selenium、BrowserStack 等工具。

4. 用户体验测试：使用用户调查、用户反馈和 A/B 测试等方法，了解用户对登录界面的满意度和改进建议。

总之，测试登录界面需要全面考虑各种可能的情况，保证登录界面的正确性、安全性和用户体验。



##### 函数指针，指针函数

在C++中，函数指针和指针函数是两个不同的概念，它们的区别如下：

1. 函数指针是一个指向函数的指针变量，它存储了函数的地址。可以通过函数指针来调用函数。例如：

```cpp
int add(int a, int b) {
    return a + b;
}

int (*p)(int, int) = &add; // 声明并初始化函数指针
int result = p(1, 2); // 使用函数指针调用函数
```

2. 指针函数是一个返回指针的函数，它定义了一个函数返回值为指针类型。例如：

```cpp
int* createArray(int size) {
    int* arr = new int[size];
    for (int i = 0; i < size; i++) {
        arr[i] = i;
    }
    return arr;
}

int* p = createArray(5); // 使用指针函数返回的指针
```

因此，函数指针和指针函数的区别在于它们的定义和使用方式不同。函数指针是一个指针变量，用于存储和调用函数的地址，而指针函数是一个函数，用于返回一个指针类型的值。

##### 使用指针出现的常见问题

使用指针在C++中是非常常见的，但也容易出现一些问题，以下是一些常见的使用指针出现的问题：

1. 空指针引用：如果指针**没有被初始化或者被赋值为nullptr**，就会出现空指针引用的问题，在访问指针指向的内存时会导致程序崩溃。

2. 悬空指针：如果指针**指向的内存被释放或者超出了其作用域**，就会出现悬空指针的问题，在访问指针指向的内存时会导致程序崩溃或者出现未定义的行为。

3. 内存泄漏：如果**动态分配的内存没有被正确地释放**，就会出现内存泄漏的问题，导致程序的内存消耗不断增加，最终导致程序崩溃。

4. 数组越界：如果**使用指针访问数组元素时越界**，就会出现数组越界的问题，导致程序崩溃或者出现未定义的行为。

5. 类型不匹配：如果**指针指向的类型和实际类型不匹配**，就会出现类型不匹配的问题，导致程序崩溃或者出现未定义的行为。

为了避免这些问题，应该在使用指针之前对指针进行初始化，避免使用空指针；在指针的作用域内使用指针，并在不需要指针时及时将其赋值为nullptr；对动态分配的内存进行正确的释放，避免出现内存泄漏；在访问数组元素时注意越界；在使用指针时进行类型检查，确保类型匹配。

##### 野指针的危害

野指针是指指向已经被释放的内存地址的指针，或者指向未经初始化的内存地址的指针。使用野指针会导致程序出现不可预测的行为，可能会引起以下危害：

1. 程序崩溃：当野指针被解引用时，程序可能会崩溃，因为指针指向的内存地址已经被释放或者未经初始化，不能被访问。

2. 内存泄漏：如果程序中存在野指针，可能会导致动态分配的内存没有被正确地释放，引发内存泄漏。

3. 数据损坏：当野指针被解引用时，可能会修改内存中的数据，导致程序出现未定义的行为或者数据损坏。

4. 安全漏洞：当野指针被解引用时，可能会导致程序出现安全漏洞，例如被黑客利用进行攻击。

为了避免野指针的危害，应该在使用指针之前对指针进行初始化，避免使用未初始化的指针；在指针的作用域内使用指针，并在不需要指针时及时将其赋值为nullptr；在释放动态分配的内存后，将指针赋值为nullptr，避免出现野指针；在使用指针时进行类型检查，确保类型匹配；在使用指针时进行边界检查，避免出现数组越界等问题。

##### 动态内存管理？动态内存管理不合理怎么办？

动态内存管理是指**在程序运行期间，通过动态分配和释放内存来管理程序中的内存使用**。C++中提供了动态内存管理的工具，包括new和delete运算符以及malloc和free函数。

动态内存管理不合理可能会导致以下问题：

1. 内存泄漏：如果动态分配的内存没有被正确地释放，就会出现内存泄漏的问题，导致程序的内存消耗不断增加，最终导致程序崩溃。

2. 悬空指针：如果动态分配的内存被释放或者超出了其作用域，就会出现悬空指针的问题，在访问指针指向的内存时会导致程序崩溃或者出现未定义的行为。

3. 双重释放：如果已经释放的内存再次被释放，就会出现双重释放的问题，导致程序崩溃或者出现未定义的行为。

4. 数组越界：如果使用动态分配的内存访问数组元素时越界，就会出现数组越界的问题，导致程序崩溃或者出现未定义的行为。

为了避免动态内存管理不合理的问题，应该遵循以下原则：

1. 在动态分配内存之前，需要仔细**考虑内存的使用情况**，避免不必要的动态内存分配。

2. 在动态分配内存之后，需要**及时将动态分配的内存释放**，防止内存泄漏。

3. 在释放动态分配的内存之后，需要**将指向该内存的指针赋值为nullptr**，以避免出现悬空指针的问题。

4. 在使用动态分配的内存时，需要**进行边界检查**，以避免出现数组越界等问题。

5. 避免使用裸指针，而应该**使用智能指针**等现代C++特性，以避免出现双重释放等问题。

总之，合理使用动态内存管理是程序设计中非常重要的一环，需要仔细考虑内存的使用情况，避免出现不必要的动态内存分配和内存泄漏等问题。

##### call异常

在C++中，call异常（也称为调用异常）通常指在函数调用期间发生的异常。当函数调用期间发生异常时，程序将跳转到异常处理程序，执行相应的异常处理操作。

call异常可能会导致以下问题：

1. 程序崩溃：当call异常没有被正确处理时，程序可能会崩溃，导致程序无法正常运行。

2. 数据损坏：当call异常没有被正确处理时，程序可能会修改内存中的数据，导致程序出现未定义的行为或者数据损坏。

3. 安全漏洞：当call异常没有被正确处理时，可能会导致程序出现安全漏洞，例如被黑客利用进行攻击。

为了避免call异常的问题，应该在程序中正确处理异常。通常的做法是在函数中**使用try-catch语句来捕获异常**，并在catch块中执行相应的异常处理操作。同时，应该注意在函数调用期间的资源管理，例如在函数中使用智能指针等RAII技术来管理动态分配的内存，以避免在发生异常时出现资源泄露等问题。

此外，也需要注意在函数调用期间的异常安全性。通常来说，函数应该保证在发生异常时不会导致程序出现不一致的状态。如果在函数中进行了一些修改操作，但是在发生异常时没有正确地回滚这些操作，就可能导致程序出现不一致的状态，从而导致程序出现未定义的行为或者数据损坏等问题。因此，在函数设计时需要考虑到异常安全性，并在函数中正确地处理异常。

##### C++和C的区别

C++和C是两种不同的编程语言，虽然它们有很多共同点，但也有很多区别。

以下是C++和C的主要区别：

1. 面向对象编程：C++是一种支持面向对象编程的语言，它允许使用类、继承、多态等概念来组织代码，以增强代码的可读性、可维护性和可扩展性。而C则不支持面向对象编程。

2. 标准库：C++标准库提供了丰富的容器、算法、输入输出等功能，以便于开发人员快速开发高质量的应用程序。而C的标准库则相对较小，只提供了基本的输入输出、字符串处理等功能。

3. 异常处理：C++支持异常处理机制，可以在代码中使用try-catch语句来捕获并处理异常。而C则不支持异常处理机制，需要使用错误代码或者返回值来处理错误情况。

4. 类型检查：C++具有更严格的类型检查机制，可以在编译时检查类型错误，以减少程序运行时出错的可能性。而C则相对较宽松一些，需要在程序运行时进行类型检查。

5. 函数重载：C++允许函数重载，即在同一个作用域内定义多个同名函数，但参数类型和/或个数不同。这样可以提高代码的可读性和可维护性。而C则不支持函数重载。

6. 内存管理：C++提供了更加灵活的内存管理机制，包括new/delete运算符、智能指针等，可以在代码中更加精细地控制内存的分配和释放。而C则需要手动管理内存，容易出现内存泄漏和悬空指针等问题。

除了以上区别之外，C++和C在语法、控制结构、运算符等方面也有一些不同。但是，由于C++是在C的基础上发展而来的，因此C++的语法和C有很多相似之处，C程序员学习C++相对较容易。

##### C和C++内存分配的方式？

C和C++都允许动态分配内存，但它们的内存分配方式略有不同。

在C中，动态内存分配通常使用标准库中的malloc()和free()函数。malloc()函数被用来分配一块指定大小的内存，并返回一个指向该内存块的指针。free()函数则用于释放先前分配的内存。

以下是一个简单的示例，演示如何在C中分配和释放内存：

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    int* p = (int*)malloc(sizeof(int) * 10); // 分配10个int类型的内存块
    if (p == NULL) {
        printf("Error: memory allocation failed!\n");
        return 1;
    }
    for (int i = 0; i < 10; i++) {
        p[i] = i;
    }
    for (int i = 0; i < 10; i++) {
        printf("%d ", p[i]);
    }
    free(p); // 释放内存

    return 0;
}
```

在C++中，动态内存分配通常使用new和delete关键字。new关键字用于分配一块指定大小的内存，并返回一个指向该内存块的指针。delete关键字则用于释放先前分配的内存。

以下是一个简单的示例，演示如何在C++中分配和释放内存：

```cpp
#include <iostream>

int main() {
    int* p = new int[10]; // 分配10个int类型的内存块
    for (int i = 0; i < 10; i++) {
        p[i] = i;
    }
    for (int i = 0; i < 10; i++) {
        std::cout << p[i] << " ";
    }
    delete[] p; // 释放内存

    return 0;
}
```

需要注意的是，在使用new分配内存时，需要使用[]来分配数组类型的内存，以便于在释放内存时正确释放全部内存块。否则，可能会出现内存泄漏的情况。

另外，C++还提供了一些高级的内存管理工具，例如智能指针（smart pointer）、容器类型等，可以更加方便地管理内存，减少内存泄漏和悬空指针等问题的出现。

**return的用法**

在C++中，return关键字用于从函数中返回值或者从函数中退出。

以下是几种常见的return用法：

1. 返回值：用于从函数中返回一个值，可以直接返回变量或者表达式的值。

```cpp
int sum(int a, int b) {
    return a + b;
}
```

2. 空返回：对于返回类型为void的函数，可以使用空返回（不带值的return语句）来退出函数。

```cpp
void func(int n) {
    if (n <= 0) {
        return; // 空返回
    }
    // 其他操作
}
```

3. 在循环中使用return：可以使用return语句提前退出循环。

```cpp
bool has_value(int arr[], int size, int value) {
    for (int i = 0; i < size; i++) {
        if (arr[i] == value) {
            return true; // 在循环中使用return提前退出
        }
    }
    return false;
}
```

4. 在try-catch块中使用return：可以在try块中抛出异常，然后在catch块中使用return语句退出函数。

```cpp
int divide(int a, int b) {
    if (b == 0) {
        throw std::invalid_argument("Divide by zero!");
    }
    return a / b;
}

int main() {
    try {
        int result = divide(10, 0);
        std::cout << "Result: " << result << std::endl;
    } catch (std::exception& e) {
        std::cerr << "Exception caught: " << e.what() << std::endl;
        return 1; // 在catch块中使用return退出函数
    }
    return 0;
}
```

需要注意的是，如果一个函数返回值的类型不是void，在函数中必须使用return语句返回一个该类型的值或者表达式的值。如果没有返回语句或者返回语句不带值，编译器可能会发出警告或者错误。

##### 智能指针

智能指针是一种特殊的指针对象，它可以自动管理所指向的动态分配内存，避免内存泄漏和悬空指针等问题。在C++中，智能指针是通过类实现的，提供了RAII（Resource Acquisition Is Initialization）语义，即**资源获取即初始化**的语义。

C++中的智能指针主要包括以下两种：

1. shared_ptr智能指针：shared_ptr指针是一种**引用计数**智能指针，它可以**跟踪有多少个指针共享同一个对象**，当最后一个指针被销毁时，它会自动释放所指向的对象。

以下是shared_ptr智能指针的示例代码：

```cpp
#include <iostream>
#include <memory>

int main() {
    std::shared_ptr<int> p1(new int(10)); // 创建一个shared_ptr指针，指向一个动态分配的int型对象
    std::shared_ptr<int> p2 = p1; // 复制一个shared_ptr指针，指向相同的对象
    std::cout << "p1: " << *p1 << ", p2: " << *p2 << std::endl;
    p1.reset(); // 释放p1指向的对象，p2仍然可用
    std::cout << "p2: " << *p2 << std::endl;
    return 0;
}
```

2. unique_ptr智能指针：unique_ptr指针是一种**独占式智能指针**，它**不能被复制或者共享**，但可以通过std::move函数转移所有权，实现指针的转移和交换。

以下是unique_ptr智能指针的示例代码：

```cpp
#include <iostream>
#include <memory>

int main() {
    std::unique_ptr<int> p1(new int(10)); // 创建一个unique_ptr指针，指向一个动态分配的int型对象
    std::unique_ptr<int> p2 = std::move(p1); // 将p1的所有权转移到p2
    std::cout << "p2: " << *p2 << std::endl;
    return 0;
}
```

需要注意的是，智能指针虽然可以自动管理内存，但也需要注意一些问题，如循环引用、多线程环境下的安全性等。因此，在使用智能指针时，需要谨慎、理解和遵循相关的规则和最佳实践。

##### 操作系统怎么进行进程管理？

操作系统通过进程管理（Process Management）来管理计算机系统中的进程（Process）。进程管理主要包括以下几个方面：

1. 进程的**创建和撤销**：操作系统可以**通过fork或者spawn等系统调用来创建一个新进程**，并**通过kill或者exit等系统调用来撤销一个进程**。

2. 进程的**调度**：操作系统需要**为多个进程分配CPU时间**，以便它们可以**在有限的CPU资源下共享CPU**。进程调度可以按照不同的算法进行，例如**先来先服务（FIFO）、最短作业优先（SJF）、时间片轮转**等。

3. 进程的**同步和通信**：当多个进程需要共享资源或者进行通信时，操作系统需要提供相应的机制，如**信号量、互斥锁、条件变量、管道、消息队列**等。

4. 进程的**状态管理**：操作系统需要跟踪每个进程的状态，例如**就绪、运行、阻塞**等，以便正确地进行进程调度和资源分配。

5. 进程的**资源管**理：操作系统需要分配和管理进程所需的各种资源，如**内存、文件、IO设备**等，以保证系统的稳定和安全。

在实际的操作系统中，进程管理是非常复杂和重要的一部分，需要考虑多种因素和限制，如进程优先级、进程间的关系、系统负载、安全性等。因此，好的进程管理策略和算法可以显著提高系统的性能和可靠性。

##### 一般应用程序的内存空间的堆栈的区别是什么？

一般应用程序的内存空间包含两个重要的内存区域，堆和栈，它们的区别如下：

1. 分配方式：堆和栈是两种不同的内存分配方式，**堆是动态分配的内存**，由程序员**使用new或malloc等函数手动分配和释放**，而**栈是静态分配的内存，由编译器自动分配和释放**。

2. 空间大小：**堆的空间大小不固定**，可以动态增长和缩小，而**栈的空间大小是固定的**，由操作系统预先分配。

3. 空间使用：堆用于存储动态分配的对象、数组等数据结构，而栈用于存储函数调用的参数、局部变量、函数返回值等。

4. 存储方式：堆的存储方式是自由存储，程序员可以根据需要随时申请和释放内存，而栈的存储方式是先进后出，遵循函数调用的顺序。

5. 内存管理：堆的内存管理需要程序员自己负责，需要手动分配和释放内存，而栈的内存管理由编译器自动完成，不需要手动管理。

需要注意的是，堆和栈虽然是两种不同的内存分配方式，但它们并不是互不相关的。在一些情况下，堆和栈可能会相互影响，如堆溢出可能导致栈的破坏，栈溢出可能导致堆的破坏。因此，在编写程序时，需要谨慎使用堆和栈，避免出现内存泄漏和内存溢出等问题。

##### 代码：插入排序，统计字符串中不同的字符出现的频率

下面是C++实现插入排序的代码示例：

```C++
#include <iostream>
using namespace std;

void insertionSort(int arr[], int n) {
    int i, j, temp;
    for (i = 1; i < n; i++) {
        temp = arr[i];
        j = i - 1;
        while (j >= 0 && arr[j] > temp) {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = temp;
    }
}

int main() {
    int arr[] = { 5, 3, 8, 6, 2, 7, 1, 4 };
    int n = sizeof(arr) / sizeof(arr[0]);

    cout << "Original array: ";
    for (int i = 0; i < n; i++) {
        cout << arr[i] << " ";
    }
    cout << endl;

    insertionSort(arr, n);

    cout << "Sorted array: ";
    for (int i = 0; i < n; i++) {
        cout << arr[i] << " ";
    }
    cout << endl;

    return 0;
}
```

该代码首先定义一个函数insertionSort，该函数使用插入排序算法对数组进行排序。然后在主函数中声明一个数组，并对该数组进行输出，调用插入排序函数对其进行排序后再输出排序后的数组。

插入排序是一种简单直观的排序算法，其**基本思想是将未排序的元素逐个插入到已排序的元素中**，从而得到一个有序的序列。在实现上，通过从第二个元素开始，逐个将元素与已排序的元素进行比较，找到其正确的位置并插入。时间复杂度为O(n^2)，不适用于大规模数据的排序。



下面是使用C++统计字符串中不同的字符出现频率的代码示例：

```C++
#include <iostream>
#include <string>
#include <map>
using namespace std;

int main() {
    string str = "hello world";
    map<char, int> freq;
    for (int i = 0; i < str.size(); i++) {
        if (str[i] != ' ') {
            freq[str[i]]++;
        }
    }
    for (auto it = freq.begin(); it != freq.end(); it++) {
        cout << it->first << ": " << it->second << endl;
    }
    return 0;
}
```

该代码首先定义一个字符串str，然后定义一个map类型的变量freq，用于记录不同字符出现的频率。接着使用for循环遍历字符串中的每个字符，如果该字符不是空格，则将其在freq中的对应值加一。最后再使用for循环遍历freq，输出每个字符及其对应的出现次数。

在实现上，使用map类型可以方便地实现字符计数功能，其key值为字符本身，value值为该字符出现的次数。由于map会对key值进行自动排序，因此输出结果也会按照字符顺序排列。

以上代码输出结果为：

```
d: 1
e: 1
h: 1
l: 3
o: 2
r: 1
w: 1
```

即字符串"hello world"中，字符'd'、'e'、'h'、'l'、'o'、'r'、'w'分别出现了1、1、1、3、2、1、1次。

##### 面向对象和面向过程的区别

面向对象和面向过程是两种不同的编程范式，它们的区别如下：

1. 抽象度不同：**面向对象编程强调的是对象的抽象**，将数据和操作封装在一个对象中，通过定义类和对象来表现问题。而**面向过程编程强调的是函数的抽象**，将处理问题的每个步骤分解为函数，通过函数来解决问题。

2. 继承与多态：面向对象编程支持**继承和多态**的概念，通过继承和多态使得代码更加灵活、易于扩展和维护。而面向过程编程不支持继承和多态的概念，代码结构相对简单，但代码的复用性和扩展性相对较低。

3. 数据封装：面向对象编程强调数据的封装，将数据和操作封装在一个对象中，通过对象来访问和处理数据。而面向过程编程不强调数据的封装，数据和操作是分开的，通过函数来访问和处理数据。

4. 程序设计思路：面向对象编程更加注重程序的设计思路，强调的是从问题本质出发，通过分析问题来设计程序。而面向过程编程更加注重程序的执行过程，强调的是从步骤出发，通过分解问题来设计程序。

需要注意的是，面向对象和面向过程并不是互相独立的，两者可以相互结合使用，根据实际情况选择合适的编程范式。在实际开发中，面向对象编程通常用于大型复杂系统的开发，而面向过程编程通常用于小型简单系统的开发。

##### OSI七层模型介绍

OSI七层模型是一种通信协议的分类标准，它将计算机网络通信协议划分为七个层次，每个层次负责不同的功能，从而实现了通信协议的模块化设计和分层实现。下面是OSI七层模型的详细介绍：

1. 应用层（Application Layer）：应用层是网络协议中的最高层，负责为用户提供各种应用服务，如**电子邮件、文件传输、Web浏览**等。**应用层协议包括HTTP、SMTP、FTP**等。

2. 表示层（Presentation Layer）：表示层主要负责**数据的格式转换、加密解密**等功能，**以便于不同系统之间的数据交换**。**表示层协议包括ASCII码、JPEG、MPEG**等。

3. 会话层（Session Layer）：会话层负责**建立、维护和结束网络连接，以确保在数据传输过程中的可靠性和完整性**。**会话层协议包括RPC、SQL**等。

4. 传输层（Transport Layer）：传输层负责**数据传输的可靠性和流量控制**，主要通过端到端的协议来实现。**传输层协议包括TCP、UDP**等。

5. 网络层（Network Layer）：网络层负责**数据包的路由和寻址，以实现不同网络之间的通信**。**网络层协议包括IP、ICMP**等。

6. 数据链路层（Data Link Layer）：数据链路层负责**数据的传输和错误检测**，以保证数据的正确性。**数据链路层协议包括以太网、ATM**等。

7. 物理层（Physical Layer）：物理层负责**数据的传输介质和物理连接的细节，包括传输速率、数据编码、电压**等。物理层协议包括RS-232、V.35等。

总的来说，OSI七层模型将计算机网络通信协议按照功能划分为七个层次，每个层次负责不同的功能，从而实现了通信协议的模块化设计和分层实现，方便了网络技术的发展和应用。

应用层封装报文交付给TCP，TCP拷贝报文到发送缓冲区，经过流量控制、拥塞控制，握手期间协商MSS，向下交付给IP，IP路由后，发现这个报文目的地址不是本网络，再到MAC，然后交给路由器，找到目标主机所在局域网后，通过碰撞避免，交付给对应主机，主机向上交付，MAC根据帧类型识别是ARP还是普通报文。

##### 详细介绍TCP三次握手过程

TCP三次握手是TCP协议用于建立可靠连接的过程，它包括三个步骤，下面是详细的介绍：

1. 第一次握手（SYN）：客户端向服务器发送一个SYN报文，表示客户端请求连接。这个报文包含了一个随机的序列号（seq）和TCP标志位SYN=1，以及客户端的初始数据包大小（MSS）等信息。

2. 第二次握手（SYN+ACK）：服务器接收到客户端的SYN报文后，向客户端发送一个SYN+ACK报文，表示服务器已经接收到客户端的请求，并准备好建立连接。这个报文包含了服务器的随机序列号（seq）和确认号（ack），以及TCP标志位SYN=1和ACK=1，表示服务器已经收到了客户端的SYN报文，并确认客户端的序列号。同时，服务器也会把自己的初始数据包大小（MSS）等信息发送给客户端。

3. 第三次握手（ACK）：客户端接收到服务器的SYN+ACK报文后，向服务器发送一个确认报文ACK，表示客户端已经接收到了服务器的SYN+ACK报文，并确认服务器的序列号。这个报文包含了客户端的确认号（ack），以及TCP标志位ACK=1，表示客户端已经确认了服务器的序列号。

当服务器收到客户端的ACK报文后，TCP连接就建立成功了。在TCP连接成功建立之后，客户端和服务器可以开始传输数据了。

需要注意的是，TCP三次握手的目的是为了确保客户端和服务器之间的通信是可靠的，可以保证数据的正确性和完整性，并防止重复连接和网络拥塞等问题。

##### 写一个选择排序

以下是用C++写的选择排序（Selection Sort）算法：

```c++
#include <iostream>
using namespace std;

void selectionSort(int arr[], int n) {
    int i, j, minIndex, temp;
    for (i = 0; i < n - 1; i++) {
        minIndex = i;  // 找到剩余部分中最小元素的下标
        for (j = i + 1; j < n; j++) {
            if (arr[j] < arr[minIndex]) {
                minIndex = j;
            }
        }
        // 将最小元素与当前位置交换
        temp = arr[minIndex];
        arr[minIndex] = arr[i];
        arr[i] = temp;
    }
}

int main() {
    int arr[] = { 5, 3, 8, 6, 2, 7, 1, 4 };
    int n = sizeof(arr) / sizeof(arr[0]);
    selectionSort(arr, n);
    cout << "Sorted array: ";
    for (int i = 0; i < n; i++) {
        cout << arr[i] << " ";
    }
    return 0;
}
```

选择排序的基本思想是**每次从剩余未排序元素中找到最小元素，放到已排序部分的末尾，直到全部元素都排好序**。在上面的实现中，我们使用了两个循环，第一个循环用于遍历整个数组，第二个循环用于在剩余部分中找到最小元素的下标。在交换元素时，我们使用了一个临时变量temp来暂存最小元素，以保证交换的正确性。

##### http和https的区别

HTTP（Hypertext Transfer Protocol）和HTTPS（HTTP Secure）都是互联网上常用的协议，用于在Web浏览器和Web服务器之间传输数据。它们之间的区别如下：

1. 安全性：HTTP是明文传输协议，数据在传输过程中容易被窃听和篡改，而HTTPS使用**SSL/TLS协议**对数据进行加密和认证，提高了数据传输的安全性。

2. 端口号：HTTP使用80端口，而HTTPS使用**443端口**。

3. 证书：HTTPS需要**使用数字证书来进行身份验证和加密数据**，而HTTP没有这个需求。

4. 速度：HTTPS的加密和认证过程需要消耗更多的计算资源，因此比HTTP稍微慢一些。

5. 缓存：由于HTTPS的数据是加密的，所以缓存起来比HTTP更加困难。

6. SEO：Google等搜索引擎会更倾向于收录HTTPS网站，提高其排名，因为HTTPS更加安全和可信。

综上所述，HTTPS相对于HTTP来说更加安全，但是需要消耗更多的计算资源和时间，因此在选择使用哪种协议时需要权衡安全性和性能的因素。



##### 判断字符串是否为IPV4

以下是使用C++判断字符串是否为IPv4的实现代码：

```c++
#include <iostream>
#include <string>
#include <vector>
using namespace std;

bool isIPv4(string str) {
    vector<string> parts;
    string part = "";
    for (char c : str) {
        if (c == '.') {
            parts.push_back(part);
            part = "";
        } else {
            part += c;
        }
    }
    parts.push_back(part); // 处理最后一个部分
    if (parts.size() != 4) {
        return false;
    }
    for (string s : parts) {
        if (s.empty() || s.size() > 3) {
            return false;
        }
        for (char c : s) {
            if (!isdigit(c)) {
                return false;
            }
        }
        if (s.size() > 1 && s[0] == '0') {
            return false;
        }
        int num = stoi(s);
        if (num < 0 || num > 255) {
            return false;
        }
    }
    return true;
}

int main() {
    string str1 = "192.168.0.1";
    string str2 = "256.168.0.1";
    string str3 = "192.168.0";
    string str4 = "192.168.0.01";
    cout << isIPv4(str1) << endl; // 1
    cout << isIPv4(str2) << endl; // 0
    cout << isIPv4(str3) << endl; // 0
    cout << isIPv4(str4) << endl; // 0
    return 0;
}
```

在上面的代码中，我们首先定义了一个isIPv4函数，该函数接受一个字符串作为参数，返回一个布尔值表示该字符串是否为IPv4地址。我们将IPv4地址划分为四个部分，使用`vector<string>`类型的parts数组来存储这四个部分，使用一个字符串part来暂存当前正在处理的部分。遍历字符串中的每个字符，如果遇到了'.'字符，则将part添加到parts数组中，并将part清空；否则，将当前字符添加到part中。最后需要再次将part添加到parts数组中，以处理最后一个部分。

接着，我们判断parts数组的大小是否为4，如果不是则返回false。然后遍历每个部分，判断是否为空或超过3个字符，是否都是数字，是否以0开头但不是0，是否在0-255之间。如果有任何一个判断条件不满足，则返回false。如果所有的部分都满足条件，则返回true。

最后，在main函数中，我们测试了一些IPv4和非IPv4的字符串，验证了isIPv4函数的正确性。



## 三、后台开发

#### 3.1 腾讯云智

自我介绍，学校学了哪些课程

##### 项目：在线加法器是什么原理，是前端计算还是后端计算，连接到数据库

##### Ubuntu和centOS有什么区别

##### IO复用：select和poll区别，epoll在Linux中有什么使用限制

STL：常用的有哪些，vector和list和map的物理结构

##### 代码：大数相加，将两个元素全为数字的string字符串相加，返回结果也是一个string

实现该功能的基本思路是模拟手算加法的过程，从低位开始逐位相加，如果有进位则向高位进位。具体实现如下：

1. 定义两个指针i和j，分别指向两个字符串的末尾。

2. 定义一个变量carry，表示进位，初值为0。

3. 从末位开始逐位相加，将结果存入一个新的字符串中。具体过程如下：

   1. 从两个字符串的末位开始，依次取出两个字符并转换为数字。如果某个字符串已经遍历完了，则将该字符当作0。

   2. 将两个数字相加，再加上进位carry，得到本位的和。

   3. 如果本位的和大于等于10，则需要进位，将进位carry设为1；否则，将进位carry设为0。

   4. 将本位的和对10取余，得到本位的结果，并将其转换为字符后存入新的字符串中。

   5. 将指针i和j分别往前移动一位，继续执行步骤3。

4. 如果最高位有进位，则将进位carry加入新的字符串中。

5. 将新的字符串翻转，得到最终结果。

下面是使用C++实现的代码：

```c++
string addStrings(string num1, string num2) {
    string res;
    int i = num1.size() - 1, j = num2.size() - 1, carry = 0;
    while (i >= 0 || j >= 0 || carry > 0) {
        int x = i >= 0 ? num1[i] - '0' : 0;
        int y = j >= 0 ? num2[j] - '0' : 0;
        int sum = x + y + carry;
        carry = sum / 10;
        res += to_string(sum % 10);
        i--;
        j--;
    }
    reverse(res.begin(), res.end());
    return res;
}
```

时间复杂度：遍历两个字符串的时间复杂度为O(max(m,n))，其中m和n分别是两个字符串的长度。翻转字符串的时间复杂度为O(max(m,n))，因此总时间复杂度为O(max(m,n))。

空间复杂度：使用了一个新的字符串，空间复杂度为O(max(m,n))。

死循环是什么现象？为什么CPU占用不是百分百？应该怎么找出BUG？

课余时间干什么事情

反问：业务？开发流程？经常学习新知识吗？

##### 智能指针

智能指针（smart pointers）是一种 C++ 中的对象，它们可以在管理动态分配的内存时提供更安全和方便的方式。智能指针的主要目的是确保在不需要使用内存时，自动释放分配给对象的内存。C++ 中提供了四种不同类型的智能指针：auto_ptr、unique_ptr、shared_ptr 和 weak_ptr。

1. auto_ptr：auto_ptr 是最早引入的一种智能指针，**它的主要特点是在赋值或者复制时，自动转移指针的所有权**。auto_ptr 已经不再被推荐使用，因为**它的所有权转移语义容易引起不可预期的行为**。

2. unique_ptr：unique_ptr 是 C++11 引入的一种智能指针，**它用于管理独占所有权的对象**，即**同一时间只能有一个 unique_ptr 指向一个对象**。当 unique_ptr 被销毁时，它会自动释放它所拥有的对象。**unique_ptr 不支持拷贝和赋值操作**，但可以通过 std::move 进行所有权的转移。

3. shared_ptr：shared_ptr 也是 C++11 引入的一种智能指针，**它用于管理共享所有权的对象，即多个 shared_ptr 可以同时指向同一个对象**。当最后一个 shared_ptr 被销毁时，它会自动释放它所拥有的对象。shared_ptr 通过**引用计数**来跟踪对象的所有权，每个 shared_ptr 都会维护一个引用计数器，当引用计数器为 0 时，对象才会被释放。shared_ptr 支持拷贝和赋值操作。

4. weak_ptr：weak_ptr 也是 C++11 引入的一种智能指针，**它用于观测 shared_ptr 拥有的对象是否存在**，但并不拥有对象的所有权。**weak_ptr 可以从 shared_ptr 创建而来，但不能直接访问共享对象，需要通过 lock() 方法获得一个 shared_ptr 对象来访问共享对象**。当最后一个 shared_ptr 被销毁时，即使还有 weak_ptr 指向对象，这些 weak_ptr 也会失效。

##### 多态

多态（polymorphism）是面向对象编程中的一个重要概念，**指的是同一操作作用于不同的对象，可以有不同的行为**。多态性是面向对象程序设计中的三大特性之一，另外两个是封装（encapsulation）和继承（inheritance）。

多态性可以通过继承和虚函数实现。当一个基类指针或引用指向一个派生类对象时，可以通过调用虚函数来实现多态性。在运行时，会根据对象的实际类型来调用相应的函数。这样可以提高代码的灵活性和可扩展性，使代码更加易于维护和扩展。

多态性有以下几种类型：

1. 静态多态性：在编译时确定函数的调用方式，如**函数重载和模板**。

2. 动态多态性：在运行时确定函数的调用方式，如**虚函数**。

3. 编译时多态性：使用**模板和泛型编程**实现的多态性。

4. 运行时多态性：使用**继承和虚函数**实现的多态性。



C++中多态的原理是通过虚函数（virtual function）和虚表（virtual table）实现的。

虚函数是一个在基类中被声明为虚拟的函数，它在派生类中被重新定义，使得派生类可以根据自己的需要对基类中的函数进行重写。**虚函数的调用是在运行时决定的**，而不是在编译时决定的。这意味着，如果基类指针或引用指向派生类对象，调用虚函数时将会根据对象的实际类型来调用相应的函数。

**虚表是一个指针数组，每个类（包括基类和派生类）都有一个虚表。虚表存储了该类中所有的虚函数的地址。当基类指针或引用指向派生类对象时，将会通过虚表来查找该派生类实现的虚函数。虚表的构建是在编译时进行的，在程序运行时不会改变。**

**当一个类包含虚函数时，编译器会为该类生成一个虚表，并在该类的对象中添加一个指向虚表的指针。当派生类重写基类的虚函数时，它会在自己的虚表中添加一个指向自己实现的函数的指针，如果派生类没有重写虚函数，它将继承基类的虚函数指针。这样，当基类指针或引用指向派生类对象时，就可以通过虚表来查找派生类实现的虚函数。**

总之，C++中多态的原理是通过虚函数和虚表来实现的，它使得程序能够在运行时根据对象的实际类型来调用相应的函数，提高了代码的灵活性和可扩展性。



虚函数和纯虚函数是C++中多态性的两个重要概念，它们的区别在于：

1. 虚函数是在基类中声明的，并在派生类中被重新定义的函数。虚函数可以被派生类覆盖，也可以被派生类继承并保留原有的定义。虚函数对于派生类来说是可选的，不一定要重写或者保留，如果派生类没有重新定义虚函数，则会使用基类中的定义。

2. 纯虚函数是在基类中声明的没有实现的虚函数，它没有函数体，只有函数声明，因此不能直接调用。**纯虚函数必须在派生类中被实现，否则派生类也将是抽象类。**在 C++ 中，可以使用 "= 0" 来声明一个纯虚函数，例如：virtual void func() = 0;

3. 对于一个类来说，如果它包含纯虚函数，则它被称为抽象类。**抽象类不能被实例化，只能作为基类来派生出其他类**。

因此，虚函数和纯虚函数的主要区别在于是否需要在基类中提供函数实现。虚函数可以有默认实现，而纯虚函数必须在派生类中实现。虚函数可以被派生类覆盖或继承，而纯虚函数必须在每个派生类中实现。虚函数的作用是实现运行时多态性，而纯虚函数的作用是定义接口和规范派生类的行为。



##### IO复用

IO复用是一种高效的I/O处理方式，可以在一个线程中同时处理多个I/O事件。在传统的I/O模型中，每个I/O操作都需要一个独立的线程，这样会导致线程数量增加，线程切换频繁，造成系统资源的浪费和延迟的增加。而IO复用可以通过一些系统调用来监控多个I/O事件，一旦有事件发生，就会通知应用程序进行处理。

在UNIX/Linux系统中，常用的IO复用模型包括select、poll和epoll。**它们的原理都是通过系统调用来监控多个文件描述符的状态，一旦其中的一个或多个文件描述符准备好进行I/O操作，就会通知应用程序进行处理。这样就可以将多个I/O事件合并到一个线程中处理，避免了线程创建、销毁和切换的开销，提高了系统的性能和响应速度。**

select是最早的IO复用模型，它需要将所有需要监控的文件描述符加入到一个集合中，然后调用select函数来等待文件描述符的事件，一旦有事件发生就会返回。但是select的缺点是效率不高，它每次都需要遍历所有的文件描述符。

poll是select的改进版本，它使用链表来存储文件描述符，相比于select，poll可以处理更多的文件描述符，并且不需要每次遍历所有的文件描述符。

epoll是Linux内核提供的一种高效的IO复用模型，它使用红黑树来存储文件描述符，可以处理数万个文件描述符，同时它还支持边缘触发和水平触发两种模式，可以根据应用程序的需要选择不同的模式。epoll比select和poll更加高效和灵活，因此在Linux系统中得到了广泛的应用。

总之，IO复用是一种高效的I/O处理方式，可以将多个I/O事件合并到一个线程中处理，减少线程的创建和切换开销，提高系统的性能和响应速度。在UNIX/Linux系统中，可以使用select、poll和epoll等函数来实现IO复用。

##### TCP三次握手

TCP三次握手是TCP协议建立可靠连接的过程，包括以下三个步骤：

1. 第一次握手：客户端发送一个SYN（同步）包给服务器，请求建立连接。该包包含客户端的初始序列号（ISN）。

2. 第二次握手：服务器收到客户端的SYN包后，发送一个SYN-ACK（同步-确认）包给客户端，表示同意建立连接。该包包含服务器的初始序列号（ISN），以及确认号（ACK）为客户端的ISN+1，表示已经收到客户端的SYN包。

3. 第三次握手：客户端收到服务器的SYN-ACK包后，发送一个ACK（确认）包给服务器，表示已经收到服务器的确认。该包包含确认号（ACK）为服务器的ISN+1，表示已经收到服务器的SYN-ACK包。

完成三次握手后，TCP连接就建立成功了。此时客户端和服务器都可以开始发送数据了。

TCP三次握手的主要目的是为了确保客户端和服务器之间的连接是可靠的，在建立连接之前，双方需要进行一系列的确认和同步操作，以确保数据能够可靠地传输。其中，第三次握手的主要作用是为了防止已经失效的连接请求被服务器接收并误认为是新的连接请求，从而导致连接的错误建立。

需要注意的是，TCP四次挥手是断开连接的过程，包括以下四个步骤：客户端发送FIN包给服务器，服务器发送ACK包给客户端，服务器发送FIN包给客户端，客户端发送ACK包给服务器。在断开连接时，也需要进行一系列的确认和同步操作，以确保数据能够完整地传输并且连接能够正确地关闭。

##### TCP拥塞控制，流量控制慢启动

TCP拥塞控制和流量控制是TCP协议保证可靠传输的关键机制。

TCP拥塞控制：当网络拥塞时，TCP协议会通过一系列的算法来调整发送数据的速率，以避免拥塞的进一步恶化。**TCP拥塞控制的主要算法包括慢启动、拥塞避免、快速重传和快速恢复。**

1. 慢启动

慢启动是 TCP 的一种拥塞控制算法。当一个 TCP 连接建立时，发送方开始发送数据，但是由于网络带宽的限制和网络拥塞的情况，如果一开始就发送大量的数据，可能会引起网络拥塞和数据丢失。

因此，TCP 引入了慢启动机制，即**一开始发送的数据量很小，然后每收到一个确认（ACK）就加倍增加发送窗口**（指定时间内可发送的数据量），**直到达到一个阈值。这个阈值被称为拥塞窗口（cwnd）**，可以动态调整。慢启动算法可以有效地避免网络拥塞和数据丢失，保证数据的可靠传输。

2. 拥塞避免

拥塞避免是 TCP 的另一种拥塞控制算法。一旦拥塞窗口达到一定阈值，TCP 就进入拥塞避免状态，此时每经过一个往返时间（RTT）就增加一个拥塞窗口大小。这样，TCP 可以逐渐增加发送速率，同时避免过度拥塞导致数据丢失。

3. 快速重传

快速重传是 TCP 的一种重传机制。如果 TCP 发送方发送了一批数据并等待确认，但是由于网络拥塞导致一些数据丢失，此时**接收方发送的 ACK 将跳过这些数据并直接确认后续的数据**。在这种情况下，**TCP 发送方不会收到确认消息，会认为这些数据已经丢失，触发重传机制**。

4. 快速恢复

快速恢复是 TCP 的一种恢复机制。当 TCP 发送方收到三个重复的 ACK 时，会认为数据包已经到达接收方，但是接收方并没有收到该数据包，即数据包已经丢失。此时，TCP 发送方并不触发超时重传机制，而是进入快速恢复状态。

在快速恢复状态下，TCP发送方不会等待超时，而是立即重传丢失的数据包。同时，发送方会将拥塞窗口减半，以减少网络拥塞的可能性。当发送方收到新的 ACK 时，就会恢复原来的拥塞窗口大小，继续发送数据。

快速恢复算法可以加快数据传输的速度，减少网络拥塞和数据丢失的可能性。同时，它也可以避免触发超时重传机制，从而提高 TCP 的性能和可靠性。

##### TCP传输数据的有序性

TCP（传输控制协议）是一种面向连接的、可靠的、基于字节流的传输协议，它确保了传输数据的有序性。

TCP 传输数据的有序性可以从以下两个方面来理解：

1. 序列号

在 TCP 中，每个数据包都有一个唯一的序列号（sequence number），用于标识发送数据的顺序。接收方通过检查序列号来确定数据包的顺序，如果发现序列号不连续，就会认为有数据包丢失，触发重传机制。

TCP 的序列号是一个 32 位的无符号整数，每次发送数据时都会加上数据长度，以确保序列号唯一。因此，即使同一数据源在短时间内发送了多个数据包，也能够保证数据的有序性。

2. 确认号

为了确保数据包的可靠传输，TCP 还引入了确认号（acknowledgment number）机制。接收方在接收到数据包后，会向发送方发送一个确认消息（ACK），其中包含确认号，表示已经成功接收到该数据包，并期待接收下一个序列号为该确认号加一的数据包。

发送方根据接收到的确认消息来确定哪些数据已经被成功接收，哪些数据需要重传。通过序列号和确认号的配合使用，TCP 可以确保数据的有序性和可靠性。

综上所述，TCP 通过序列号和确认号的机制，保证了传输数据的有序性，从而确保数据的可靠传输。

##### 数据库索引（聚簇索引）

数据库索引是一种数据结构，用于加速数据库查询操作。它是数据库中的一种重要组件，可以大大提高查询效率，减少查询时间。索引可以看作是数据库表中某些列的快速查找表，可以根据特定的列值快速定位到对应的记录。

**数据库索引可以分为主键索引、唯一索引、普通索引**等几种类型。其中，主键索引是一种特殊的索引，它是唯一的且非空的，用于保证表中每一行的唯一性，一般是对表的主键列建立索引。唯一索引是指除了主键外，表中的某一列具有唯一性，一般是对该列建立唯一索引。普通索引则是指对表中的某一列建立的一般索引，用于加速查询操作。

数据库索引的实现方式有多种，其中最常见的是**B-tree和哈希表**。B-tree是一种平衡树结构，可以高效地支持范围查询和排序操作，适用于范围查询比较频繁的场景。哈希表则是一种散列结构，可以高效地支持等值查询，适用于等值查询比较频繁的场景。

在使用数据库索引时，需要注意以下几点：

1. 索引会占用一定的存储空间，因此需要根据实际情况慎重选择需要建立索引的列。

2. 索引的维护会影响插入、更新、删除等操作的性能，因此需要根据实际情况平衡查询效率和维护成本。

3. 索引的选择需要考虑查询的类型和数据分布情况，以便选择最适合的索引类型和数据结构。

总之，数据库索引是一种重要的数据结构，可以大大提高数据库查询效率，但需要根据实际情况慎重选择索引列和索引类型，以平衡查询效率和维护成本。



聚簇索引是一种特殊的数据库索引，它是将表中的数据按照聚簇索引列的值进行排序，并将数据存储在磁盘上相邻的位置上，因此聚簇索引也被称为聚集索引。在聚簇索引中，表中的每一行数据都与一个索引键相关联，而索引键的值决定了该行数据在磁盘上的存储位置。

聚簇索引的优点是可以大大提高查询性能，因为它可以将相邻的数据存储在一起，减少了磁盘I/O操作的次数。此外，聚簇索引还可以提高数据的插入和更新性能，因为它可以避免数据的重排序和重定位。

在使用聚簇索引时，需要注意以下几点：

1. 表中只能有一个聚簇索引，因为聚簇索引决定了表中数据的物理存储方式。

2. 聚簇索引的选择需要根据实际情况进行慎重考虑。如果选择的聚簇索引列不是查询的常用条件，反而会降低查询性能。

3. 聚簇索引的维护成本比较高，因为每次插入或更新数据时，都需要对索引进行重排序和重定位。

总之，聚簇索引是一种特殊的数据库索引，可以大大提高查询性能和数据的插入和更新性能，但需要根据实际情况进行慎重选择和使用，以平衡查询性能和维护成本。



聚簇索引和非聚簇索引是两种不同的数据库索引类型，它们的主要区别在于索引的物理存储方式和维护成本。

1. 物理存储方式：聚簇索引将表中的数据按照聚簇索引列的值进行排序，并将数据存储在磁盘上相邻的位置上，因此聚簇索引也被称为聚集索引。而非聚簇索引则是将索引列的值和对应的行记录的地址存储在一个独立的数据结构中，不影响表中数据的物理存储方式。

2. 维护成本：聚簇索引的维护成本比较高，因为每次插入或更新数据时，都需要对索引进行重排序和重定位。而非聚簇索引的维护成本相对较低，因为它只需要更新索引的数据结构，不需要对表中的数据进行排序和重定位。

3. 查询性能：聚簇索引可以大大提高查询性能，因为它可以将相邻的数据存储在一起，减少了磁盘I/O操作的次数。而非聚簇索引的查询性能相对较低，因为它需要先从索引中找到对应的行记录的地址，然后再到表中进行查询。

4. 使用限制：一个表只能有一个聚簇索引，而非聚簇索引可以有多个。此外，聚簇索引只能建立在支持排序的列上，而非聚簇索引可以建立在任何列上。

总之，聚簇索引和非聚簇索引是两种不同的数据库索引类型，它们的主要区别在于索引的物理存储方式、维护成本和查询性能。需要根据实际情况选择适合的索引类型，以提高查询性能和降低维护成本。

聚簇索引是数据与索引绑定，非聚簇索引是数据与索引分离。



##### MyISAM和InnoDB

MyISAM和InnoDB都是MySQL数据库中常用的存储引擎。

MyISAM是MySQL的默认存储引擎，它的主要特点是**查询速度快，占用资源少，适合于读密集型应用**。**MyISAM的缺点是不支持事务和行级锁定**，因此在并发写入操作时容易出现数据冲突和数据丢失等问题。此外，MyISAM还不支持外键约束和崩溃恢复等功能。

InnoDB是MySQL的另一种存储引擎，它的主要特点是**支持事务和行级锁定，适合于写密集型应用**。InnoDB的缺点是相比MyISAM，它的**查询速度稍慢，占用资源稍多**。此外，InnoDB支持外键约束和崩溃恢复等功能，但是在一些特殊情况下，这些功能可能会导致性能下降。

在选择MyISAM和InnoDB存储引擎时，需要根据实际情况进行权衡。如果应用程序以查询为主，而对写操作的并发性和完整性要求不高，可以选择MyISAM。如果应用程序需要支持事务和行级锁定，并且对写操作的并发性和完整性有较高要求，则应选择InnoDB。此外，需要注意的是，由于MyISAM不支持事务和行级锁定，因此在使用MyISAM存储引擎时，需要通过其他方式来保证数据的一致性和完整性，例如使用锁定机制或者应用程序级别的检查和处理。



##### C++中保证线程安全

C++是一种多线程编程语言，为了保证多线程程序的正确性，需要采取一些措施来避免竞态条件和其他的线程安全问题。以下是一些常用的保证C++线程安全的方法：

1. 使用原子操作：原子操作是指不可被中断的操作，可以保证多线程环境下数据的正确性。C++11中引入了原子操作库，可以通过原子操作来保证共享变量的线程安全。

2. 使用互斥锁：互斥锁是一种同步机制，可以保证同一时间只有一个线程能够访问共享变量。C++中提供了mutex、recursive_mutex、timed_mutex等互斥锁类型，可以使用这些锁来保证线程安全。

3. 使用条件变量：条件变量是一种同步机制，可以使得一个线程等待另一个线程满足某个条件之后再继续执行。C++中提供了condition_variable和condition_variable_any两种条件变量类型，可以使用这些变量来保证线程安全。

4. 使用读写锁：读写锁是一种特殊的互斥锁，可以允许多个线程同时读取共享数据，但只允许一个线程写入共享数据。C++中提供了shared_mutex和shared_timed_mutex两种读写锁类型，可以使用这些锁来提高多线程程序的性能。

5. 避免数据共享：尽可能地避免多个线程同时访问同一个共享变量，可以通过拷贝数据、局部化变量等方式来避免数据共享，从而减少竞争条件的出现。

总之，C++中有多种方法可以保证线程安全，开发者需要根据实际情况选择合适的方法。在编写多线程程序时，一定要注意竞态条件和其他线程安全问题，避免出现数据不一致或者死锁等问题。



##### 锁机制

锁是一种同步机制，用于保护共享资源，防止多个线程同时访问同一个共享资源而导致的竞争条件和其他线程安全问题。常见的锁机制包括以下几种：

1. 互斥锁（Mutex）：互斥锁是一种最基本的锁机制，它可以**保证同一时间只有一个线程能够访问共享资源**。当一个线程获得互斥锁后，其他线程将会被阻塞，直到该线程释放锁为止。

2. 读写锁（ReadWrite Lock）：读写锁是一种特殊的锁机制，它可以**允许多个线程同时读取共享资源，但只允许一个线程写入共享资源**。读写锁采用共享模式和排他模式来保护共享资源，可以提高多线程程序的性能。

3. 自旋锁（Spin Lock）：自旋锁是一种特殊的锁机制，它**不会使线程进入阻塞状态，而是通过循环不断地检查锁状态来尝试获取锁**。当锁被其他线程占用时，自旋锁会一直循环等待，直到锁可用为止。

4. 条件变量（Condition Variable）：条件变量是一种同步机制，它可以**使得一个线程等待另一个线程满足某个条件之后再继续执行**。条件变量通常与互斥锁一起使用，可以保证线程安全。

5. 原子操作（Atomic Operation）：原子操作是一种不可被中断的操作，可以保证多线程环境下数据的正确性。原子操作通常用于保护共享变量，可以避免竞态条件和其他线程安全问题。

总之，锁机制是保证多线程程序正确性的重要手段，开发者需要根据实际情况选择合适的锁机制。在使用锁机制时，需要注意避免死锁、饥饿等问题，保证程序的正确性和性能。
