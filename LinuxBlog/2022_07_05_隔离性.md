下面进一步理解隔离性。

数据库并发的场景最多的还是读+写。为了解决读些冲突的问题，介绍：

- 3个记录隐藏列字段

如果一个表只有姓名和年龄的字段，但真正的表是下面这样的

| name | age  | DB_TRX_ID | DB_ROLL_PTR | DB_ROW_ID |
| ---- | ---- | --------- | ----------- | --------- |
| 张三 | 28   | null      | 1           | null      |

DB_TRX_ID: 6 byte，最近修改事务ID，记录创建这条记录/最后一次修改该记录的事务ID。

DB_ROLL_PTR: 7 byte，回滚指针，指向这条记录的上一个版本(简单理解成，指向历史版本就行，这些数据一般在` undo log` 中)。

DB_ROW_ID: 6 byte，隐含的自增ID(隐藏主键)，如果数据表没有主键，会自动以产生一个聚簇索引。

* `undo` 日志

mysql日志有三种，`undo log` 支持回滚操作，`redo log` 持久化的日志（进行数据落盘、持久化和CS崩溃时安全工作），`bin log` 二进制日志（记录大部分所有的用户操作，负责主从备份，默认是未打开的）。

这些日志内容若没被刷新，也是会在mysql的缓冲区里面的（不一定是在buffer pool）。

- MVCC

就是多版本控制器。

举例：有一个事务10，对表中字段name进行修改，将张三改为李四。

事务10，因为要修改，所以要先给该记录加行锁。
修改前，现将改行记录拷贝到undo log中，所以，undo log中就有了一行副本数据。(原理就是写时拷贝) 所以现在mysql中有两行同样的记录。现在修改原始记录中的name，改成 '李四'。并且修改原始记录的隐藏字段`DB_TRX_ID`为当前`事务10`的ID, 我们默认从 10 开始，之后递增。而原始记录的回滚指针 `DB_ROLL_PTR`列， 里面写入undo log中副本数据的地址，从而指向副本记录，既表示我的上一个版本就是它。 事务10提交，释放锁。

通过回滚指针指向undo log的某行记录而形成的结构，被称为「历史版本链」。

于是事务中的信息就可以被追溯：追溯谁修改的记录，查看上一个记录是什么。

事务的回滚，本质其实就是历史版本，覆盖新版本。历史版本也被叫做「快照」。



总结：`update`和`delete`可以形成版本链，`insert`暂时不考虑。`select` 读取分为「当前读」和「快照读」，前者读取最新记录，后者读取历史版本。

所以如果是『快照读』，读取历史版本是不受加锁限制，于是可以并行执行，加快效率就是MVCC的意义。



**为什么要有隔离级别呢？**

事务是原子性的，所以事务总有先后。

那么隔离性可以理解为，不同事务对不同历史版本的访问。当所有事务都被提交后，快照就因没有意义了而被清除。读取到不同版本的历史版本，也就体现了不同程度的隔离级别。

**那是如何做到让不同事务能看到不同版本呢？**

举个例子，张三在儿子三岁的时候犯错进监狱了，五年后出狱时，他心中儿子的模样还是三岁时。

mysql是用C++实现该功能的，有一个类叫`read view` ，这个类负责管理当前活跃事务的ID，是在事务进行快照读的时候产生的读视图(read view)。用来判断当前事务能够看到哪个版本的数据。

注意：read view不是创建事务就有，而是形成于首次进行快照读。

新来的事务ID也会比旧的大。

read view类中比较重要的成员有：

```c++
m_ids;	// 一张列表，用来维护Read View生成时刻，系统正活跃的事务ID
up_limit_id;	// 记录m_ids列表中事务ID最小的ID
low_limit_id;	// Read View生成时刻系统尚未分配的下一个事务，即最大事务ID+1
creator_trx_id;	// 创建该Read View的事务ID
```



我们在实际读取数据版本链的时候，是能读取到每一个版本对应的事务ID的，即`DB_TRX_ID`。

那么手里的东西有：当前快照读的ReadView和版本链中的某一个记录的`DB_TRX_ID`。

现在研究，当前快照读应不应该读到当前版本记录。

首先，事务可以分为3个阶段，已经提交的事务，正在操作的事务，以及快照后新来的事务。

**阶段一：已经提交的事务**

这个阶段内，可能有已经begin的事务，但这些事务并没有对数据进行任何修改，也就没有任何版本链，那么历史上已经提交的事务都能看到。

底层逻辑为`creator_trx_id == DB_TRX_ID || DB_TRX_ID < up_limit_id`

即创建读视图的事务ID等于最近修改的事务ID，或者最近修改的事务ID小于m_ids列表中事务ID最小的ID

**阶段二：正在操作的事务**

这个阶段是形成快照后，可能有多个事务，对数据进行读写。这些事务都只能看到已经提交的事务，不能看到存在事务ID列表中事务的版本。

注意，事务ID是连续且单增的，但不代表大的ID就一定能看到小的ID版本，反之亦然。比如11、12、

13、14号事务，12、13先commit，11看不到14的，但11和14都可以看到13和12的，13和12却看不到11和14的。

底层逻辑为：如果DB_TRX_ID不在m_ids列表中，说明已经提交，其他事务都能看到。如果不在，说明是活跃事务，没有commit就不能被看到。

**阶段三：快照后新来的事务**

底层逻辑：`DB_TRX_ID >= low_limit_id`

即最近修改的事务ID大于等于最大事务ID+1

这些事务是在快照之后提交，不应该看到。



接下来通过举例子来熟悉上面的三个阶段：

现在有记录

| name | age  | DB_TRX_ID | DB_ROLL_PTR | DB_ROW_ID |
| ---- | ---- | --------- | ----------- | :-------- |
| 张三 | 28   | null      | 1           | null      |

事务操作

| 事务1    | 事务2    | 事务3    | 事务4      |
| -------- | -------- | -------- | ---------- |
| 事务开始 | 事务开始 | 事务开始 | 事务开始   |
|          |          |          | 修改且提交 |
|          | 快照读   |          |            |

事务4修改name为李四。当事务2快照读时生成ReadView读视图。

其中的成员为

```c++
m_ids;	// 1, 3
up_limit_id;	// 1
low_limit_id;	// 4 + 1 ReadView生成的时候，系统未分配下一个事务ID
creator_trx_id;	// 2
```

快照读该行记录时，就会拿该行记录的DB_TRX_ID去和up_limit_id, low_limit_id和活跃事务ID列表比较，判断当前事务2能看到该记录的版本。

DB_TRX_ID(4)< up_limit_id(1) ? 不小于，下一步

DB_TRX_ID(4)>= low_limit_id(5) ? 不大于，下一步 

m_ids.contains(DB_TRX_ID) ? 不包含，说明，事务4不在当前的活跃事务中。

故事务4的更改，能被看到。



- Repeatable-Read与Read-Commit的本质区别

在RR下，事务中快照读的结果是非常依赖该事务首次出现快照读的地方，这会决定该事务后续快照读的能力。

举个例子，事务A和事务B同时begin，事务A先进行快照读，然后修改数据，事务A提交后，事务B再进行快照读，读到的就是A修改后的数据。如果事务B在A提交前进行快照读，B在提交前，就看不到A的修改。

**RR的总结：**

1. ReadView生成生成时机的不同，从而造成RC，RR级别下快照读的结果的不同。
2. 在RR级别下，某个事务的某条记录的第一次快照读会创建一个快照和ReadView，将当前系统活跃的其他事务记录起来。
3. 此后在调用快照读的时候，还是使用的是同一个Read View，所以只要当前事务在其他事务提交更新之前使用过快照读，那么之后的快照读使用的都是同一个Read View，所以对之后的修改不可见。
4. 即RR级别下，快照读生成Read View时，Read View会记录此时所有其他活动事务的快照，这些事务的修改对于当前事务都是不可见的。

**RC的总结：**

1. 在RC级别下的事务中，每次快照读都会生成并获取最新的Read View
2. 正因如此，RC才有不可重复读问题。